DF <- DF[order(DF$time),]
head(DF)
df.sd <- df.sd/sqrt(6) # Calculate SE from SD
head(df.sd)
sqrt(6)
head(DF)
#' Find EVT files with a recursive search down a directory tree.#
#'#
#' @param evt.dir Directory containing EVT files.#
#' @return Vector of EVT files with julian day directory.#
#' @examples#
#' \dontrun{#
#' evt.files <- get.evt.files(evt.dir)#
#' }#
#' @export#
get.evt.files <- function(evt.dir) {#
  file.list <- list.files(evt.dir, recursive=T)#
  if (length(file.list) == 0) {#
    print(paste("no evt files found in", evt.dir))#
    return(file.list)#
  }#
  # regexp to match both types of EVT files#
  #   - 37.evt (old style)#
  #   - 2014-05-15T17-07-08+0000 or 2014-07-04T00-03-02+00-00 (new style)#
  # In the new style the final timezone offset may not always be UTC (00-00)#
  # so be sure to correctly parse it in all code.#
  regexp <- "/?[0-9]+\\.evt(\\.gz)?$|/?[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}-[0-9]{2}-[0-9]{2}[+-][0-9]{2}-?[0-9]{2}(\\.gz)?$"#
  id <- grep(regexp,file.list)#
  file.list <- file.list[id]#
  #print(paste(length(file.list), "evt files found"))#
  return(sort(unlist(lapply(file.list, clean.file.path))))#
}#
#
#' Find the most recent EVT file.#
#'#
#' @param evt.dir Directory containing EVT files.#
#' @return Most recent EVT file with julian day directory.#
#' @examples#
#' \dontrun{#
#' evt.file <- get.latest.evt(evt.dir)#
#' }#
#' @export#
get.latest.evt <- function(evt.dir) {#
  file.list <- get.evt.files(evt.dir)#
  n <- length(file.list)#
  return(clean.file.path(file.list[n]))#
}#
#
#' file.transfer#
#'#
#' @return None#
#' @export#
file.transfer <- function(evt.dir, instrument.dir){#
#
  last.evt <- get.latest.evt(evt.dir)#
  file.list <- list.files(instrument.dir, recursive=T)#
  sfl.list <- file.list[grepl('.sfl', file.list)]#
  file.list <- file.list[-length(file.list)] # remove the last file (opened file)#
  file.list <- sort(file.list[!grepl('.sfl', file.list)])#
#
  id <- match(last.evt, file.list)#
#
  if(length(id) == 0){#
    day <- unique(dirname(file.list))#
      for(d in day) system(paste0("mkdir ",evt.dir,"/",d))#
    print(paste0("scp ",instrument.dir,"/",file.list," ", evt.dir,"/",file.list))#
    system(paste0("scp ",instrument.dir,"/",file.list," ", evt.dir,"/",file.list, collapse=";"))#
    system(paste0("scp ",instrument.dir,"/",sfl.list," ", evt.dir,"/",sfl.list, collapse=";"))#
  }#
  else{#
    file.list <- file.list[id:length(file.list)]#
    day <- unique(dirname(file.list))#
      for(d in day) system(paste0("mkdir ",evt.dir,"/",d))#
    print(paste0("scp ",instrument.dir,"/",file.list," ", evt.dir,"/",file.list))#
    system(paste0("scp ",instrument.dir,"/",file.list," ", evt.dir,"/",file.list, collapse=";"))#
    system(paste0("scp ",instrument.dir,"/",sfl.list," ", evt.dir,"/",sfl.list, collapse=";"))#
  }#
 }#
#
#' Clean a file path.#
#'#
#' Convert an EVT/OPP/VCT file path to a form suitable for storage in the SQLite#
#' db. Any ".gz", ".opp", ".vct" extensions will be removed.#
#'#
#' @param fpath File path to clean.#
#' @return Modified file path as julian_day/EVT_file_name.#
#' @examples#
#' \dontrun{#
#' fpath <- clean.file.path("foo/2014_185/2014-07-04T00-00-02+00-00.opp.gz")#
#' }#
#' @export#
clean.file.path <- function(fpath) {#
  # Clean up any places with multiple "/"s#
  fpath <- gsub("/+", "/", fpath)#
#
  # Check for julian day directory#
  parts <- unlist(strsplit(fpath, "/"))#
  if (length(parts) < 2) {#
    stop(paste0("file path ", fpath, " must contain a julian day directory"))#
  }#
#
  file.name <- parts[length(parts)]#
  julian.day <- parts[length(parts)-1]#
#
  julian.regexp <- "^[0-9]{4}_[0-9]+$"#
  if (length(grep(julian.regexp, julian.day)) != 1) {#
    stop(paste0("Julian day directory does not match pattern YYYY_day in ", fpath))#
  }#
#
  # Get rid of any .gz extension#
  if (nchar(file.name) >= 3) {#
    if (substr(file.name, nchar(file.name) - 2, nchar(file.name)) == ".gz") {#
      file.name <- substr(file.name, 1, nchar(file.name) - 3)#
    }#
  }#
#
  # Get rid of any .opp extension#
  if (nchar(file.name) >= 4) {#
    if (substr(file.name, nchar(file.name) - 3, nchar(file.name)) == ".opp") {#
      file.name <- substr(file.name, 1, nchar(file.name) - 4)#
    }#
  }#
#
  # Get rid of any .vct extension#
  if (nchar(file.name) >= 4) {#
    if (substr(file.name, nchar(file.name) - 3, nchar(file.name)) == ".vct") {#
      file.name <- substr(file.name, 1, nchar(file.name) - 4)#
    }#
  }#
#
  return(paste(julian.day, file.name, sep="/"))#
}#
#
#' Check if file path ends with suffix#
#'#
#' @param path File path to test.#
#' @param ending String suffix to test#
#' @return TRUE or FALSE if path ends with ending. If either path or ending has#
#'   length zero or if ending is longer than path, return FALSE.#
#' @examples#
#' \dontrun{#
#' endswith("foo/bar.txt", ".txt") # TRUE#
#' endswith("foo/bar.txt", ".gz")  # FALSE#
#' }#
endswith <- function(path, ending) {#
  psize <- nchar(path)#
  esize <- nchar(ending)#
  if (psize > 0 && esize > 0 && psize >= esize) {#
    return(substr(path, psize - esize + 1, psize) == ending)#
  }#
  return(FALSE)#
}#
#' Extract dawn and dusk times from a time series of PAR values#
#'#
#' Extracts the time that dawn and dusk occur from a time series consisting of PAR values (light intensity).#
#' Dawn is defined as the point where the par value goes from night -> day.#
#' Dusk is defined as the point where the par value goes from day -> night.#
#' This is useful for gating purposes for flow- cytometry.#
#' Dawn and dusk tend to represent the extrema of flourences for phytoplankton.#
#' @param x A data frame with two columns. The first column must be time values#
#'    in as.POSIXct format. The second column must be PAR values.#
#' @param cutoff An integer representing the smallest par value that is considered#
#'  daytime.#
#' @return A vector consisting of dawn and dusk time values in as.POSIXct format#
#' @examples#
#' \dontrun{#
#' par.data.csv <- system.file("extdata/par_data.csv", package="popcycle")#
#' par.data <- read.csv(par.data.csv)#
#' par.data$date <- as.POSIXct(par.data$date, format = "%FT%T", tz = "GMT")#
#' dawn.dusk.times <- get.dawn.dusk.time(par.data, 10)#
#' }#
#' @export#
get.dawn.dusk.time <- function(x, cutoff) {#
    # assign names to the time and par parameters#
    time <- x[,1]#
    par <- x[,2]#
#
    # We will define dawn and dusk times to occur when par goes from above 10 -> below 10,#
    # or from below 10 -> above 10#
    above <- par > cutoff#
    intersect <- which(diff(above)!=0)#
#
    # We will then make sure we are only getting points that fall within the sequential pattern#
    # of natural dusk and dawns, AKA they must be separated by same time intervals#
#
    #revision <- intersect[which(diff(intersect) > mean(diff(intersect)))]#
    #dawn.dusk <- time[revision]#
#
    dawn.dusk <- time[intersect]#
    return(dawn.dusk)#
}#
#' Concatenate EVT or OPP files#
#'#
#' @param evtopp.list List of EVT or OPP files (full path required).#
#' @param n Number of rows to return.#
#' @param min.fsc, min.pe, min.chl Minimum value for fsc_small, pe and chl_small respectively#
#' @return A dataframe with n rows.#
#' @export#
concatenate.evtopp <- function(evtopp.list, n=100000, min.fsc=0, min.pe=0, min.chl=0, transform=TRUE,...){#
  n <- as.numeric(n)#
  DF <- NULL#
  i <- 0#
  for (file in evtopp.list){#
        message(round(100*i/length(evtopp.list)), "% completed \r", appendLF=FALSE)#
#
        tryCatch({#
          df <- readSeaflow(file,transform=transform,...)#
          df <- subset(df, fsc_small > min.fsc & pe > min.pe & chl_small > min.chl)#
          df <- df[round(seq(1,nrow(df), length.out=round(n/length(evtopp.list)))),]#
#
            if(any(is.na(df))) next#
            DF <- rbind(DF, df)#
            }, error = function(e) {#
              cat(paste0("Error with file ", file, ": ", e))#
          })#
#
          i <- i + 1#
          flush.console()#
          }#
#
      return(DF)#
}#
#' Calculation of flow rate based on stream pressure measured by SeaFlow#
#'#
#' @param dataframe that contains stream pressure measured by SeaFlow (available in SFL table and STAT table). Note that the dataframe needs to have a column named 'stream_pressure'#
#' @param inst Instrument serial. If not provided this will attempt to be#
#'   parsed from the SFL file name (<cruise>_<serial>.sfl).#
#' @return A dataframe with flow rate estimates#
#' @export#
#
flowrate <- function(stat, inst=NULL){#
#
  if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("flowrate", paste0("lm_",inst),package='popcycle'))#
    fr <- predict(reg, newdata=data.frame(measured.pressure=log10(stat$stream_pressure)),interval='predict')#
#
    stat$flow_rate <- 10^fr[,"fit"] # mL min-1#
    stat$flow_rate.se <- stat$flow_rate * abs((fr[,"upr"]-fr[,"lwr"])/(2 * 1.96 * fr[,"fit"]))#
#
  return(stat)#
#
}#
#' Get aggregate statistics data frame along with estimates of cell abundance.#
#'#
#' @param db SQLite3 database file path.#
#' @param inst Instrument serial. If not provided this will attempt to be#
#'   parsed from the SFL file name (<cruise>_<serial>.sfl).#
#' @return Data frame of aggregate statistics.#
#' @examples#
#' \dontrun{#
#' stats <- get.stat.table(db, inst=NULL)#
#' }#
#' @export#
get.stat.table <- function(db, inst=NULL) {#
#
  if(is.null(inst)) inst <- get.meta(db)[2]#
#
  # ratio of the volume of the stream analyzed by the laser (aka, detectable region) to the whole water stream (200 µm nozzle) for that instrument#
    if(inst == "740") VC <- 0.136#
    if(inst == "751") VC <- 0.143#
    if(inst == "989") VC <- 0.149#
#
  DF <- get.raw.stat.table(db)#
  stat <- flowrate(DF, inst=inst)#
  stat[,c("abundance")]  <- stat[,"n_count"] / (1000*VC * stat[,"opp_evt_ratio"] * stat[,c("flow_rate")] * stat[,"file_duration"]/60)   # cells µL-1#
  stat[,c("abundance.se")]  <- stat[,c("abundance")] * stat[,c("flow_rate.se")] / stat[,c("flow_rate")]           # cells µL-1#
#
  return(stat)#
#
}#
#
#' Normalization by beads used as internal standard#
#'#
#' @param stat Stat table generated by the function get.stat.table().#
#' @param spar smooothing parameter, the higher the more smoothing is applied.#
#' @return A dataframe with normalized D1, D2, fsc_small, chl_small, pe and fsc_perp values#
#' @export#
normalization <- function(stat, spar=0.7){#
#
  #check that there is beads in the table#
  if(!any(unique(stat$pop) == 'beads')){#
    print("no beads found, normalization can't be done")#
    stop#
  }#
#
  time <- as.POSIXct(stat$time, format = "%FT%T", tz = "GMT")#
  beads <- subset(stat, pop =='beads' & quantile== 50)#
    beads$time <- as.POSIXct(beads$time, format = "%FT%T", tz = "GMT")#
#
    channels <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp")#
#
  par(mfrow=c(3,2),cex=1.2, mar=c(2,5,1,1), oma=c(1,1,1,1))#
#
    for(para in channels){#
          smooth <- smooth.spline(beads$time, beads[,para],spar=spar)#
          smooth.beads <- spline(smooth$x, smooth$y, xout=unique(time))#
          plot(beads$time, beads[,para], ylim=c(1, 10^3.5), log='y', xlab=NA, ylab=paste(para))#
            lines(smooth.beads, col=2, lwd=3)#
          id <- findInterval(time,beads$time)#
          stat[,para] <- stat[,para] / smooth.beads$y[id]#
          }#
#
  return(stat)#
#
}#
#' Estimate Carbon cell quotas and biomass based on normalized foward scatter to 1-µm beads used as internal standard#
#'#
#' @param stat Table generated by the function normalization().#
#' @param inst Instrument serial. If not provided this will attempt to be#
#'   parsed from the SFL file name (<cruise>_<serial>.sfl).#
#' @return A dataframe with carbon cell quotas and biomass#
#' @export#
carbon_conversion <- function(stat, inst=NULL){#
#
  if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("cbiomass", paste0("lm_",inst),package='popcycle'))#
  qc <- predict(reg, newdata=data.frame(norm.fsc=log10(stat$fsc_small)),interval='predict')#
#
  stat[,"Qc"] <- 10^qc[,"fit"] * 1000        # fgC cell-1#
  stat[,"Qc.se"] <-   stat[,"Qc"] * abs((qc[,"upr"]-qc[,"lwr"])/(2*1.96 * qc[,"fit"]))   # fgC cell-1#
  stat[,"Cbiomass"] <- stat[,"Qc"] * stat[,"abundance"] / 1000      # pgC L-1#
  stat[,"Cbiomass.se"] <- stat[,"Cbiomass"] * (stat[,"abundance.se"] / stat[,"abundance"] + stat[,"Qc.se"] / stat[,"Qc"]) # pgC L-1#
#
  return(stat)#
#
}#
#
#' Calculate mean  + sd of aggregate statistics data from the 3 OPP data sets (2.5, 50 and 97.5 qunatile).#
#'#
#' @param stat. Table generated by the function carbon_conversion.#
#' @return Data frame of aggregate statistics.#
#' @examples#
#' \dontrun{#
#' DF <- merge.stat(stat)#
#' }#
#' @export#
#
merge.stat <- function(stat){#
#
    para <- c("abundance", "Qc","Cbiomass")#
    lwr <- upr <- stat#
      for(p in para) lwr[,p] <- stat[,p]-stat[,paste0(p,".se")]#
      for(p in para) upr[,p] <- stat[,p]+stat[,paste0(p,".se")]#
      df <- rbind(lwr,upr)#
#
    para <- colnames(stat)[-c(1,2,13,21,23,25,27,29)]#
      df.mean <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=mean)#
      df.mean$file <- stat[match(df.mean$time, stat$time),"file"]#
#
    para <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp","abundance", "Qc","Cbiomass")#
      df.sd <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=sd)[,-c(1,2)]#
      df.se <- df.sd/sqrt(6) # Calculate SE from SD#
      colnames(df.se) <- paste0(para,".se")#
#
      DF <- cbind(df.mean,df.se)#
      DF <- DF[order(DF$time),]#
#
      return(DF)#
}#
#' Get aggregate statistics data frame along with propagation of errors#
#'#
#' @param db SQLite3 database file path.#
#' @param inst Instrument serial. If not provided this will attempt to be#
#'   parsed from the SFL file name (<cruise>_<serial>.sfl).#
#' @param spar smooothing parameter, the higher the more smoothing is applied.#
#' @param Whether the list of files flagged as outliers should be merged to the dataframe of aggregate statistics#
#' @return Data frame of aggregate statistics.#
#' @examples#
#' \dontrun{#
#' stat <- get.clean.stat.table(db, inst=NULL, spar=0.7, flag=F)#
#' }#
#' @export#
get.clean.stat.table <- function(db, inst=NULL, spar=0.7, flag=T){#
#
  DF <- get.raw.stat.table(db)#
  stat <- flowrate(DF, inst=inst)#
  stat <- normalization(stat, spar=spar)#
  stat <- carbon_conversion(stat, inst=inst)#
  stat <- merge.stat(stat)#
#
  if(flag){#
    outlier <- get.outlier.table(db)#
    if(nrow(outlier) > 0){#
      stat <- merge(stat, outlier, all.x=TRUE)#
    }else print("No flagged file found!")#
  }#
#
  return(stat)#
#
}
df <- get.clean.stat.table(db, spar=0.5, flag=F)
get.clean.stat.table <- function(db, inst=NULL, spar=0.7, flag=T){#
#
  DF <- get.raw.stat.table(db); print("1. getting raw data")#
  stat <- flowrate(DF, inst=inst); print("2. adding flow rate")#
  stat <- normalization(stat, spar=spar); print("3. normalization of channels by 1 µm based")#
  stat <- carbon_conversion(stat, inst=inst); print("4.converting normalized light scattering to carbon")#
  stat <- merge.stat(stat); print("5. Propagating error")#
#
  if(flag){#
    outlier <- get.outlier.table(db)#
    if(nrow(outlier) > 0){#
      stat <- merge(stat, outlier, all.x=TRUE)#
    }else print("No flagged file found!")#
  }#
#
  return(stat)
}
df <- get.clean.stat.table(db, spar=0.5, flag=F)
DF <- get.raw.stat.table(db); print("1. Getting raw data")#
  stat <- flowrate(DF, inst=inst); print("2. Adding flow rate")
stat <- get.stat.table(db, inst=inst); print("1. Getting raw data")#
  stat <- normalization(stat, spar=spar); print("2. Normalizing channel values to 1 µm based")
stat <- carbon_conversion(stat, inst=inst); print("3. Converting normalized light scattering to carbon")
stat <- merge.stat(stat); print("4. Propagating error")
print("1. Getting raw data"); stat <- get.stat.table(db, inst=inst); #
  print("2. Normalizing channel values to 1 µm based"); stat <- normalization(stat, spar=spar)#
  print("3. Converting normalized light scattering to carbon"); stat <- carbon_conversion(stat, inst=inst); #
  print("4. Propagating error"); stat <- merge.stat(stat)
head(stat)
outlier <- get.outlier.table(db)
<- get.outlier.table(db)
outlier
stat <- merge(stat, outlier, all.x=TRUE)
head(stat)
get.clean.stat.table <- function(db, inst=NULL, spar=0.7){#
#
  print("1. Getting raw data"); stat <- get.stat.table(db, inst=inst); #
  print("2. Normalizing channel values to 1 µm based"); stat <- normalization(stat, spar=spar)#
  print("3. Converting normalized light scattering to carbon"); stat <- carbon_conversion(stat, inst=inst); #
  print("4. Propagating error"); stat <- merge.stat(stat)#
#
  outlier <- get.outlier.table(db)#
  stat <- merge(stat, outlier, all.x=TRUE)#
#
  return(stat)#
#
}
stat <- get.stat.table(db, inst=inst); print("1. Getting raw data")#
  stat <- normalization(stat, spar=spar); print("2. Normalizing channel values to 1 µm based")
stat <- get.clean.stat.table(db, inst=NULL, spar=0.7)
stat <- get.clean.stat.table(db, inst=NULL, spar=0.2)
param <- "fsc_small"
paste0(param,".se")
colnames(stat)
any(colnames(stat))== paste0(param,".se")
colnames(stat)
any(colnames(stat)== paste0(param,".se"))
param <- 'ff'
any(colnames(stat)== paste0(param,".se"))
stat$time <- as.POSIXct(stat$time,format="%FT%T",tz='GMT')#
  pop <- subset(stat, pop == popname)#
  if(any(colnames(stat)== paste0(param,".se"))) plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname),...)
pop <- subset(stat, population == popname)
popname <- "prochloro"
stat$time <- as.POSIXct(stat$time,format="%FT%T",tz='GMT')#
  pop <- subset(stat, population == popname)
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname))
library(plotCI)
library(plotrix)
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname))
param <- 'abundance'
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname))
param <- "fsc_small"
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname))
mean(pop$abundance.se / pop$abundance)
?plotCI
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey')
param <- 'abundance'
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey')
popname <- 'picoeuks'
stat$time <- as.POSIXct(stat$time,format="%FT%T",tz='GMT')#
  pop <- subset(stat, population == popname)#
  if(any(colnames(stat)== paste0(param,".se"))) plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey')
popname <- 'picoeuk'
stat$time <- as.POSIXct(stat$time,format="%FT%T",tz='GMT')#
  pop <- subset(stat, population == popname)#
  if(any(colnames(stat)== paste0(param,".se"))) plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey')
if(any(colnames(stat)== paste0(param,".se"))) plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey',log='y')
plotCI
plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".se")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey')
head(stat)
if(is.null(inst)) inst <- get.meta(db)[2]#
#
  # ratio of the volume of the stream analyzed by the laser (aka, detectable region) to the whole water stream (200 µm nozzle) for that instrument#
    if(inst == "740") VC <- 0.136#
    if(inst == "751") VC <- 0.143#
    if(inst == "989") VC <- 0.149#
#
  DF <- get.raw.stat.table(db)#
  stat <- flowrate(DF, inst=inst)
library(popcycle)
cruise <- "SCOPE_2"#
    path <- "/Volumes/Ribalet External/SeaFlow-OPP/"#
    opp.dir <- paste0(path,cruise, "/",cruise,"_opp")#
    vct.dir <- paste0(path,cruise, "/", cruise, "_vct")#
    db <- paste0(path,cruise, "/",cruise,".db")
inst=NULL
if(is.null(inst)) inst <- get.meta(db)[2]#
#
  # ratio of the volume of the stream analyzed by the laser (aka, detectable region) to the whole water stream (200 µm nozzle) for that instrument#
    if(inst == "740") VC <- 0.136#
    if(inst == "751") VC <- 0.143#
    if(inst == "989") VC <- 0.149#
#
  DF <- get.raw.stat.table(db)#
  stat <- flowrate(DF, inst=inst)
head(stat)
id <- which(stat$pop == 'prochloro')
length(id)
path <- "/Volumes/Ribalet External/SeaFlow-OPP/"
library(popcycle)
list.dirs(path=path)
list.dirs
cruiselist <- list.dirs(path=path, recursive=F)
cruiselist
?grep
grep("refilter",cruiselist)
cruiselist <- list.dirs(path=path, recursive=F)[-grep("refilter",cruiselist)]
cruiselist
cruise <-cruiselist[2]
cruise
paste0(path,cruise, "/",cruise,".db")
basename(cruise)
paste0(path,cruise, "/",basename(cruise),".db")
#sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")
t <- sql.dbGetQuery(db, sql)
library(popcycle)#
    # sqlite3 path/to/CRUISE.db#
    # drop view stat;#
    # sqlite3 path/to/CRUISE.db <path/to/popcycle/inst/sql/popcycle.sql#
#
path <- "/Volumes/Ribalet External/SeaFlow-OPP/"#
#
cruiselist <- list.dirs(path=path, recursive=F)[-grep("refilter",cruiselist)]
cruiselist <- cruiselist[-grep("refilter",cruiselist)]
cruiselist <- list.dirs(path=path, recursive=F)#
cruiselist <- cruiselist[-grep("refilter",cruiselist)]
cruiselist
print(cruise)#
      #cruise <-cruiselist[2]#
      db <- paste0(path,cruise, "/",basename(cruise),".db")#
#
      #sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")#
#
    t <- sql.dbGetQuery(db, sql)
cruise <-cruiselist[2]#
      db <- paste0(path,cruise, "/",basename(cruise),".db")#
#
      #sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")
t <- sql.dbGetQuery(db, sql)
db
print(cruise)
paste0(cruise, "/",basename(cruise),".db")
print(cruise)#
      #cruise <-cruiselist[2]#
      db <- paste0(cruise, "/",basename(cruise),".db")#
#
      #sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")#
#
    t <- sql.dbGetQuery(db, sql)
head(t)
t
sql.dbGetQuery
system(paste("sqlite3", db, "<~/Documents/DATA/Codes/popcycle/inst/sql/popcycle.sql"))
paste("sqlite3", db, "<~/Documents/DATA/Codes/popcycle/inst/sql/popcycle.sql")
path <- "/Volumes/OPPdata/SeaFlow-OPP/"#
#
cruiselist <- list.dirs(path=path, recursive=F)#
cruiselist <- cruiselist[-grep("refilter",cruiselist)]
print(cruise)#
      #cruise <-cruiselist[2]#
      db <- paste0(cruise, "/",basename(cruise),".db")#
#
      #sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")#
#
    t <- sql.dbGetQuery(db, sql)#
    print(t[1,])#
    system(paste("sqlite3", db, "<~/Documents/DATA/Codes/popcycle/inst/sql/popcycle.sql"))
# sqlite3 path/to/CRUISE.db <path/to/popcycle/inst/sql/popcycle.sql#
#
path <- "/Volumes/OPPdata/SeaFlow-OPP/"#
#
cruiselist <- list.dirs(path=path, recursive=F)#
cruiselist <- cruiselist[-grep("refilter",cruiselist)]
cruiselist
print(cruise)
cruise <-cruiselist[2]#
      db <- paste0(cruise, "/",basename(cruise),".db")#
#
      #sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")#
#
    t <- sql.dbGetQuery(db, sql)#
    print(t[1,])#
    system(paste("sqlite3", db, "<~/Documents/DATA/Codes/popcycle/inst/sql/popcycle.sql"))
for(cruise in cruiselist){#
#
      print(cruise)#
      #cruise <-cruiselist[2]#
      db <- paste0(cruise, "/",basename(cruise),".db")#
#
      #sql <- paste0("SELECT * FROM stat")#
      #sql <- paste0("drop table sfl")#
      #sql <- paste0("drop table vct")#
      sql <- paste0("drop view stat")#
#
    t <- sql.dbGetQuery(db, sql)#
    print(t[1,])#
    system(paste("sqlite3", db, "<~/Documents/DATA/Codes/popcycle/inst/sql/popcycle.sql"))#
#
    }
?get.clean.stat.table
library(popcycle)#
    cruise <- "SCOPE_2"#
    path <- "/Volumes/OPPdata/SeaFlow-OPP/"#
    opp.dir <- paste0(path,cruise, "/",cruise,"_opp")#
    vct.dir <- paste0(path,cruise, "/", cruise, "_vct")#
    db <- paste0(path,cruise, "/",cruise,".db")
inst=NULL
print("1. Getting raw data"); stat <- get.stat.table(db, inst=inst);
load(system.file("flowrate", paste0("lm_",inst),package='popcycle'))#
    fr <- predict(reg, newdata=data.frame(measured.pressure=log10(stat$stream_pressure)),interval='predict')
if(is.null(inst)) inst <- get.meta(db)[2]
load(system.file("flowrate", paste0("lm_",inst),package='popcycle'))
fr <- predict(reg, newdata=data.frame(measured.pressure=log10(stat$stream_pressure)),interval='predict')
sd(fr)
head(fr)
?apply
apply(fr, 2, sd)
apply(fr, 1, sd)
stat$flow_rate.sd <- 10^apply(fr, 1, sd)
head(stat)
flowrate <- function(stat, inst=NULL){#
#
  if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("flowrate", paste0("lm_",inst),package='popcycle'))#
    fr <- predict(reg, newdata=data.frame(measured.pressure=log10(stat$stream_pressure)),interval='predict')#
#
    stat$flow_rate <- 10^fr[,"fit"] # mL min-1#
    stat$flow_rate.sd <- 10^apply(fr, 1, sd)#
#
    return(stat)#
#
}
if(is.null(inst)) inst <- get.meta(db)[2]#
#
  # ratio of the volume of the stream analyzed by the laser (aka, detectable region) to the whole water stream (200 µm nozzle) for that instrument#
    if(inst == "740") VC <- 0.136#
    if(inst == "751") VC <- 0.143#
    if(inst == "989") VC <- 0.149#
#
  DF <- get.raw.stat.table(db)#
  stat <- flowrate(DF, inst=inst)#
#
  # abundance is calculated based on a median value of opp_evt ratio for the entire cruise (volume of virtual core set for an entire cruise)#
  stat[,c("abundance")]  <- stat[,"n_count"] / (1000*VC * median(stat[,"opp_evt_ratio"], na.rm=T) * stat[,c("flow_rate")] * stat[,"file_duration"]/60)   # cells µL-1#
  stat[,c("abundance.sd")]  <- stat[,c("abundance")] * stat[,c("flow_rate.sd")] / stat[,c("flow_rate")]           # cells µL-1#
#
  # If Prochlorococcus present, abundance is calculated based on individual opp_evt ratio (each file), since it provides more accurate results (see https://github.com/armbrustlab/seaflow-virtualcore)#
    id <- which(stat$pop == 'prochloro')#
    if(length(id) > 0){#
      stat[id,c("abundance")]  <- stat[id,"n_count"] / (1000*VC * stat[id,"opp_evt_ratio"] * stat[id,c("flow_rate")] * stat[id,"file_duration"]/60)   # cells µL-1#
      stat[id,c("abundance.sd")]  <- stat[id,c("abundance")] * stat[id,c("flow_rate.sd")] / stat[id,c("flow_rate")]           # cells µL-1#
    }
head(stat)
#check that there is beads in the table#
  if(!any(unique(stat$pop) == 'beads')){#
    print("no beads found, normalization can't be done")#
    stop#
  }#
#
  time <- as.POSIXct(stat$time, format = "%FT%T", tz = "GMT")#
  beads <- subset(stat, pop =='beads' & quantile== 50)#
    beads$time <- as.POSIXct(beads$time, format = "%FT%T", tz = "GMT")#
#
    channels <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp")#
#
  par(mfrow=c(3,2),cex=1.2, mar=c(2,5,1,1), oma=c(1,1,1,1))#
#
    for(para in channels){#
          smooth <- smooth.spline(beads$time, beads[,para],spar=spar)#
          smooth.beads <- spline(smooth$x, smooth$y, xout=unique(time))#
          plot(beads$time, beads[,para], ylim=c(1, 10^3.5), log='y', xlab=NA, ylab=paste(para))#
            lines(smooth.beads, col=2, lwd=3)#
          id <- findInterval(time,beads$time)#
          stat[,para] <- stat[,para] / smooth.beads$y[id]#
          }
spar=0.7
#check that there is beads in the table#
  if(!any(unique(stat$pop) == 'beads')){#
    print("no beads found, normalization can't be done")#
    stop#
  }#
#
  time <- as.POSIXct(stat$time, format = "%FT%T", tz = "GMT")#
  beads <- subset(stat, pop =='beads' & quantile== 50)#
    beads$time <- as.POSIXct(beads$time, format = "%FT%T", tz = "GMT")#
#
    channels <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp")#
#
  par(mfrow=c(3,2),cex=1.2, mar=c(2,5,1,1), oma=c(1,1,1,1))#
#
    for(para in channels){#
          smooth <- smooth.spline(beads$time, beads[,para],spar=spar)#
          smooth.beads <- spline(smooth$x, smooth$y, xout=unique(time))#
          plot(beads$time, beads[,para], ylim=c(1, 10^3.5), log='y', xlab=NA, ylab=paste(para))#
            lines(smooth.beads, col=2, lwd=3)#
          id <- findInterval(time,beads$time)#
          stat[,para] <- stat[,para] / smooth.beads$y[id]#
          }
if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("cbiomass", paste0("lm_",inst),package='popcycle'))#
  qc <- predict(reg, newdata=data.frame(norm.fsc=log10(stat$fsc_small)),interval='predict')
head(qc)
if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("cbiomass", paste0("lm_",inst),package='popcycle'))#
  qc <- predict(reg, newdata=data.frame(norm.fsc=log10(stat$fsc_small)),interval='predict')#
#
  stat[,"Qc"] <- 10^qc[,"fit"] * 1000        # fgC cell-1#
  stat[,"Qc.sd"] <-   10^apply(qc, 1, sd)   # fgC cell-1#
  stat[,"Cbiomass"] <- stat[,"Qc"] * stat[,"abundance"] / 1000      # pgC L-1#
  stat[,"Cbiomass.sd"] <- stat[,"Cbiomass"] * (stat[,"abundance.sd"] / stat[,"abundance"] + stat[,"Qc.sd"] / stat[,"Qc"]) # pgC L-1
head(stat)
head(qc)
head(apply(qc, 1, sd))
if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("cbiomass", paste0("lm_",inst),package='popcycle'))#
  qc <- predict(reg, newdata=data.frame(norm.fsc=log10(stat$fsc_small)),interval='predict')#
#
  stat[,"Qc"] <- 10^qc[,"fit"] * 1000        # fgC cell-1#
  stat[,"Qc.sd"] <-   10^apply(qc, 1, sd) * 1000  # fgC cell-1#
  stat[,"Cbiomass"] <- stat[,"Qc"] * stat[,"abundance"] / 1000      # pgC L-1#
  stat[,"Cbiomass.sd"] <- stat[,"Cbiomass"] * (stat[,"abundance.sd"] / stat[,"abundance"] + stat[,"Qc.sd"] / stat[,"Qc"]) # pgC L-1
head(stat)
para <- c("abundance", "Qc","Cbiomass")#
    lwr <- upr <- stat#
      for(p in para) lwr[,p] <- stat[,p]-stat[,paste0(p,".se")]#
      for(p in para) upr[,p] <- stat[,p]+stat[,paste0(p,".se")]#
      df <- rbind(lwr,upr)#
#
    para <- colnames(stat)[-c(1,2,13,21,23,25,27,29)]#
      df.mean <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=mean)#
      df.mean$file <- stat[match(df.mean$time, stat$time),"file"]#
#
    para <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp","abundance", "Qc","Cbiomass")#
      df.sd <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=sd)[,-c(1,2)]#
      df.se <- df.sd/sqrt(6) # Calculate SE from SD#
      colnames(df.se) <- paste0(para,".se")#
#
      DF <- cbind(df.mean,df.se)#
      DF <- DF[order(DF$time),]
para <- c("abundance", "Qc","Cbiomass")#
    lwr <- upr <- stat#
      for(p in para) lwr[,p] <- stat[,p]-stat[,paste0(p,".se")]#
      for(p in para) upr[,p] <- stat[,p]+stat[,paste0(p,".se")]#
      df <- rbind(lwr,upr)#
#
    para <- colnames(stat)[-c(1,2,13,21,23,25,27,29)]#
      df.mean <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=mean)#
      df.mean$file <- stat[match(df.mean$time, stat$time),"file"]#
#
    para <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp","abundance", "Qc","Cbiomass")#
      df.sd <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=sd)[,-c(1,2)]#
      colnames(df.sd) <- paste0(para,".sd")#
#
      DF <- cbind(df.mean,df.sd)#
      DF <- DF[order(DF$time),]
para <- c("abundance", "Qc","Cbiomass")#
    lwr <- upr <- stat#
      for(p in para) lwr[,p] <- stat[,p]-stat[,paste0(p,".sd")]#
      for(p in para) upr[,p] <- stat[,p]+stat[,paste0(p,".sd")]#
      df <- rbind(lwr,upr)#
#
    para <- colnames(stat)[-c(1,2,13,21,23,25,27,29)]#
      df.mean <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=mean)#
      df.mean$file <- stat[match(df.mean$time, stat$time),"file"]#
#
    para <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp","abundance", "Qc","Cbiomass")#
      df.sd <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=sd)[,-c(1,2)]#
      colnames(df.sd) <- paste0(para,".sd")#
#
      DF <- cbind(df.mean,df.sd)#
      DF <- DF[order(DF$time),]
head(DF)
head(stat[,"abundance.sd"] / stat[,"abundance"])
head(stat[,"Qc.sd"] / stat[,"Qc"])
head(apply(fr, 1, sd)/fr[,"fit"])
head(stat$flow_rate*apply(fr, 1, sd)/fr[,"fit"])
flowrate
head(2.303 * stat$flow_rate*apply(fr, 1, sd))
stat <- get.raw.stat.table(db)
head(stat)
#' @export#
flowrate <- function(stat, inst=NULL){#
#
  if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("flowrate", paste0("lm_",inst),package='popcycle'))#
    fr <- predict(reg, newdata=data.frame(measured.pressure=log10(stat$stream_pressure)),interval='predict')#
#
    stat$flow_rate <- 10^fr[,"fit"] # mL min-1#
    stat$flow_rate.sd <- 2.303 * stat$flow_rate * apply(fr, 1, sd)) # uncertainties Antilog, based 10 : y=10^a so Sy= 2.303 * y * Sa#
#
    return(stat)#
#
}
flowrate <- function(stat, inst=NULL){#
#
  if(is.null(inst)) inst <- get.meta(db)[2]#
#
  load(system.file("flowrate", paste0("lm_",inst),package='popcycle'))#
    fr <- predict(reg, newdata=data.frame(measured.pressure=log10(stat$stream_pressure)),interval='predict')#
#
    stat$flow_rate <- 10^fr[,"fit"] # mL min-1#
    stat$flow_rate.sd <- 2.303 * stat$flow_rate * apply(fr, 1, sd) # uncertainties Antilog, based 10 : y=10^a so Sy= 2.303 * y * Sa#
#
    return(stat)#
#
}
stat <- flowrate(stat, inst=inst)
head(stat)
stat[,c("abundance")]  <- stat[,"n_count"] / (1000*VC * median(stat[,"opp_evt_ratio"], na.rm=T) * stat[,"flow_rate"] * stat[,"file_duration"]/60)   # cells µL-1#
  stat[,c("abundance.sd")]  <- stat[,"abundance"] * stat[,"flow_rate.sd"] / stat[,"flow_rate"]           # cells µL-1#
#
  # If Prochlorococcus present, abundance is calculated based on individual opp_evt ratio (each file), since it provides more accurate results (see https://github.com/armbrustlab/seaflow-virtualcore)#
    id <- which(stat$pop == 'prochloro')#
    if(length(id) > 0){#
      stat[id,c("abundance")]  <- stat[id,"n_count"] / (1000*VC * stat[id,"opp_evt_ratio"] * stat[id,"flow_rate"] * stat[id,"file_duration"]/60)   # cells µL-1#
      stat[id,c("abundance.sd")]  <- stat[id,"abundance"] * stat[id,"flow_rate.sd"] / stat[id,"flow_rate"]           # cells µL-1#
    }
head(stat)
#check that there is beads in the table#
  if(!any(unique(stat$pop) == 'beads')){#
    print("no beads found, normalization can't be done")#
    stop#
  }#
#
  time <- as.POSIXct(stat$time, format = "%FT%T", tz = "GMT")#
  beads <- subset(stat, pop =='beads' & quantile== 50)#
    beads$time <- as.POSIXct(beads$time, format = "%FT%T", tz = "GMT")#
#
    channels <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp")#
#
  par(mfrow=c(3,2),cex=1.2, mar=c(2,5,1,1), oma=c(1,1,1,1))#
#
    for(para in channels){#
          smooth <- smooth.spline(beads$time, beads[,para],spar=spar)#
          smooth.beads <- spline(smooth$x, smooth$y, xout=unique(time))#
          plot(beads$time, beads[,para], ylim=c(1, 10^3.5), log='y', xlab=NA, ylab=paste(para))#
            lines(smooth.beads, col=2, lwd=3)#
          id <- findInterval(time,beads$time)#
          stat[,para] <- stat[,para] / smooth.beads$y[id]#
          }
load(system.file("cbiomass", paste0("lm_",inst),package='popcycle'))#
  qc <- predict(reg, newdata=data.frame(norm.fsc=log10(stat$fsc_small)),interval='predict')#
#
  stat[,"Qc"] <- 10^qc[,"fit"] * 1000        # fgC cell-1#
  stat[,"Qc.sd"] <-   2.303 * stat[,"Qc"] * apply(qc, 1, sd) # uncertainties Antilog, based 10 : y=10^a so Sy= 2.303 * y * Sa#
  stat[,"Cbiomass"] <- stat[,"Qc"] * stat[,"abundance"] / 1000      # pgC L-1#
  stat[,"Cbiomass.sd"] <- stat[,"Cbiomass"] * sqrt((stat[,"abundance.sd"] / stat[,"abundance"])^2 + (stat[,"Qc.sd"] / stat[,"Qc"])^2) # pgC L-1
head(stat)
para <- c("abundance", "Qc","Cbiomass")#
    lwr <- upr <- stat#
      for(p in para) lwr[,p] <- stat[,p]-stat[,paste0(p,".sd")]#
      for(p in para) upr[,p] <- stat[,p]+stat[,paste0(p,".sd")]#
      df <- rbind(lwr,upr)#
#
    para <- colnames(stat)[-c(1,2,13,21,23,25,27,29)]#
      df.mean <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=mean)#
      df.mean$file <- stat[match(df.mean$time, stat$time),"file"]#
#
    para <- c("D1","D2","fsc_small","chl_small","pe","fsc_perp","abundance", "Qc","Cbiomass")#
      df.sd <- aggregate(df[,para], by=list(time=df$time, population=df$pop), FUN=sd)[,-c(1,2)]#
      colnames(df.sd) <- paste0(para,".sd")#
#
      DF <- cbind(df.mean,df.sd)#
      DF <- DF[order(DF$time),]
head(DF)
log(10)
plot.time
library(popcycle)#
    cruise <- "SCOPE_2"#
    path <- "/Volumes/OPPdata/SeaFlow-OPP/"#
    opp.dir <- paste0(path,cruise, "/",cruise,"_opp")#
    vct.dir <- paste0(path,cruise, "/", cruise, "_vct")#
    db <- paste0(path,cruise, "/",cruise,".db")
stat <- get.clean.stat.table(db, spar=0.7)
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))#
for(i in phyto){#
        plot.time(clean, popname=i, param="abundance", xlim=lim.t)    #
	}
lim.t <- c(min(as.POSIXct(stat$time),na.rm=T), max(as.POSIXct(stat$time),na.rm=T))#
phyto <- unique(stat$population)#
#
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))
plot.time(stat popname=i, param="abundance", xlim=lim.t)
plot.time(stat, popname=i, param="abundance", xlim=lim.t)
for(i in phyto){#
        plot.time(stat, popname=i, param="abundance", xlim=lim.t)    #
	}
head9stat
head(stat)
plot.time
plot.time <- function(stat, popname,param, ...){#
  require(plotrix, quietly=T)#
#
  stat$time <- as.POSIXct(stat$time,format="%FT%T",tz='GMT')#
  pop <- subset(stat, population == popname)#
  if(any(colnames(stat)== paste0(param,".sd"))) plotCI(pop$time, pop[,param], uiw=pop[,paste0(param,".sd")], sfrac=0,xlab="Time", ylab=paste(param),main=paste(popname), scol='grey',...)#
  else plot(pop$time, pop[,param], xlab="Time", ylab=paste(param),main=paste(popname),...)#
}
for(i in phyto){#
        plot.time(stat, popname=i, param="abundance", xlim=lim.t)    #
	}
for(i in phyto){#
        plot.time(stat, popname=i, param="Qc", xlim=lim.t)    #
	}
for(i in phyto){#
        plot.time(stat, popname=i, param="Cbiomass", xlim=lim.t)    #
	}
head(stat)
clean <- subset(stat, flag == 0)
for(i in phyto){#
        plot.time(clean, popname=i, param="abundance", xlim=lim.t)    #
	}
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))#
for(i in phyto){#
        plot.time(clean, popname=i, param="abundance", xlim=lim.t)    #
	}
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))#
for(i in phyto){#
        plot.time(clean, popname=i, param="Cbiomass", xlim=lim.t)    #
	}
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))#
for(i in phyto){#
        plot.time(clean, popname=i, param="Qc", xlim=lim.t)    #
	}
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))#
for(i in phyto){#
        plot.time(clean, popname=i, param="fsc_small", xlim=lim.t)    #
	}
cex <- 1#
par(mfrow=c(ceiling(length(phyto)/2),2), cex=cex, mar=c(2,4,2,3), oma=c(2,1,1,1))#
for(i in phyto){#
        plot.time(clean, popname=i, param="abundance", xlim=lim.t)    #
	}
stat <- get.clean.stat.table(db, spar=0.7)
clean <- subset(stat, flag == 0)
plot.time(clean, popname='prochloro', param='abundance',log='y')
plot.time(clean, popname='prochloro', param='abundance')
plot.time(clean, popname='picoeuk', param='abundance')
plot.time(clean, popname='prochloro', param='abundance',log='y')
plot.time(clean, popname='picoeuk', param='abundance',log='y')
par(mfrow=c(4,2))#
    plot.time(clean, popname='prochloro', param='abundance')#
    plot.time(clean, popname='picoeuk', param='abundance')#
    plot.time(clean, popname='prochloro', param='fsc_small')#
    plot.time(clean, popname='picoeuk', param='fsc_small')#
    plot.time(clean, popname='prochloro', param='Qc')#
    plot.time(clean, popname='picoeuk', param='Qc')#
    plot.time(clean, popname='prochloro', param='Cbiomass')#
    plot.time(clean, popname='picoeuk', param='Cbiomass')
sqrt(1.5^2 + 4^2)
library(popcycle)#
library(dplyr)#
cols <- colorRampPalette(c("blue4", "royalblue4", "deepskyblue3", "seagreen3", "yellow", "orangered2", "darkred"))#
##########################################
## 0. DOWNLOAD THE RAW DATA using DAT ####
##########################################
dat://fa2bb5981465ff583e091071f2f2c5e5f1b118c5219971a2dde107e4dec25e63#
#
#Path to the raw data (DAT)#
path.to.data <- "~/Documents/DATA/Codes/seaflow-virtualcore/seaflow-virtualcore-data/"#
#####################################
### 1. SET FILTRATION PARAMETERS ####
#####################################
df <- c("MBARI1",47814,24114,22436,#
"SCOPE6",49664,16840,17669,#
"DeepDOM",48977,19167,19617,#
"Gradient1",51625,34693,33630)#
beads.coord <- data.frame(matrix(df, 4,4, byrow=T),stringsAsFactors=F)#
colnames(beads.coord) <- c("cruise","fsc","d1","d2")#
#Path to the Git repository#
setwd("~/Documents/DATA/Codes/seaflow-virtualcore/2.cruise_calibration/")#
gate <- FALSE#
allcruises <- c("SCOPE6", "DeepDOM", "MBARI1","Gradient1")#
#
for(cruise in allcruises){#
#
  #cruise <- allcruises[1]#
#
  print(cruise)#
  ### Get EVT list#
  if(cruise == "SCOPE6" | cruise == "Gradient1") list <- list.files(paste0(path.to.data,cruise,"data"), "00-00$",full.names=T, recursive=T)#
  if(cruise == "DeepDOM"| cruise == "MBARI1") list <- list.files(paste0(path.to.data,cruise,"data"), ".evt$",full.names=T, recursive=T)#
#
  if(cruise == "SCOPE6") inst <- 740#
  if(cruise == "DeepDOM" | cruise == "MBARI1") inst <- 989#
  if(cruise == "Gradient1") inst <- 751#
#
  # SLOPES#
  slopes <- read.csv("seaflow_filter_slopes.csv")#
#
  # BEADS#
  beads.fsc <- as.numeric(beads.coord[which(beads.coord$cruise == cruise),"fsc"])#
  beads.d1 <- as.numeric(beads.coord[which(beads.coord$cruise == cruise),"d1"])#
  beads.d2 <- as.numeric(beads.coord[which(beads.coord$cruise == cruise),"d2"])#
#
width <- 2500#
ALL <- NULL#
#
for (file in list){#
#
  #file <- list[4]#
  print(file)#
#
  evt <- readSeaflow(file,transform=F)#
#
  # Filtering noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2), with Correction for the difference of sensitivity between D1 and D2#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
    if(nrow(aligned)> 100000){aligned. <- sample_n(aligned, 100000)#
      } else aligned. <- aligned#
#
    if(nrow(evt.)> 100000){df <- sample_n(evt., 100000)#
      } else df <- evt.#
    # par(mfrow=c(2,2))#
    # plot.cytogram(df, "D1", "D2"); abline(b=notch, a=origin)#
    # plot.cytogram(aligned., "D1", "D2"); abline(b=1, a=origin)#
    # plot.cytogram(df, "fsc_small", "D1"); abline(b=notch.small.D1, a=offset.small.D1,col=2); abline(b=notch.large.D1, a=offset.large.D1,col=3); points(beads.fsc, beads.d1,pch=16, col=3)#
    # plot.cytogram(df, "fsc_small", "D2"); abline(b=notch.small.D2, a=offset.small.D2,col=2); abline(b=notch.large.D2, a=offset.large.D2,col=3); points(beads.fsc, beads.d2,pch=16, col=3)#
#
    screening <- c(-12500,-10000,-7500,-5000,-2500,0,2500,5000,7500,10000,12500, 1, 2, 3)#
#
  for(corr in screening){#
#
  print(paste("corr=", corr))#
  notch.small.D1 <- slopes[slopes$ins== inst,'notch.small.D1']#
  notch.small.D2 <- slopes[slopes$ins== inst,'notch.small.D2']#
  notch.large.D1 <- slopes[slopes$ins== inst,'notch.large.D1']#
  notch.large.D2 <- slopes[slopes$ins== inst,'notch.large.D2']#
  offset.small.D1 <- round(beads.d1 - notch.small.D1 * beads.fsc) + corr#
  offset.small.D2 <- round(beads.d2 - notch.small.D2 * beads.fsc) + corr#
  offset.large.D1 <- round(beads.d1 - notch.large.D1 * beads.fsc) + corr#
  offset.large.D2 <- round(beads.d2 - notch.large.D2 * beads.fsc) + corr#
    if(corr == 1){#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      notch.small.D1 <- slopes[slopes$ins== inst,'notch.small.D1']#
      notch.small.D2 <- slopes[slopes$ins== inst,'notch.small.D2']#
      }#
#
    if(corr == 2){#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      notch.small.D1 <- beads.d1/beads.fsc#
      notch.small.D2 <- beads.d2/beads.fsc#
      }#
#
    if(corr == 3){#
        if(offset.small.D1 < 0 | offset.small.D2 < 0){#
                    offset.small.D1 <- 0#
                    offset.small.D2 <- 0#
                    notch.small.D1 <- beads.d1/beads.fsc#
                    notch.small.D2 <- beads.d2/beads.fsc}#
        }#
#
      opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
        D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
      if(nrow(opp) < 10) next#
#
      opp$pop <- 0#
      opp. <- subset(opp, fsc_small > 1)#
#
      print("Beads")#
        if(gate) {plot.cytogram(opp , "fsc_small", "pe")#
                        poly.beads <- getpoly(quiet=TRUE)#
                        write.csv(poly.beads,paste0(cruise,"data/", basename(file),"-polybeads.csv"),quote=F, row.names=F)#
                      }#
        poly.beads <-  read.csv(paste0(cruise,"data/", basename(file),"-polybeads.csv"))#
        b <- subset(opp,inout(opp[,c("fsc_small", "pe")],poly=poly.beads, bound=TRUE, quiet=TRUE))#
        opp[row.names(b),'pop'] <- "beads"#
#
      print("Syn")#
        if(gate) {poly.syn <- getpoly(quiet=TRUE)#
                        write.csv(poly.syn,paste0(cruise,"data/", basename(file),"-polysyn.csv"),quote=F, row.names=F)#
                      }#
        poly.syn <-  read.csv(paste0(cruise,"data/", basename(file),"-polysyn.csv"))#
        s <- subset(opp,inout(opp[,c("fsc_small", "pe")],poly=poly.syn, bound=TRUE, quiet=TRUE))#
        opp[row.names(s),'pop'] <- "synecho"#
#
      print("Pro")#
      x <- subset(opp, pop==0)#
        if(gate){plot.cytogram(opp , "fsc_small", "chl_small")#
                        poly.pro <- getpoly(quiet=TRUE)#
                        write.csv(poly.pro,paste0(cruise,"data/", basename(file),"-polypro.csv"),quote=F, row.names=F)#
                      }#
        poly.pro <-  read.csv(paste0(cruise,"data/", basename(file),"-polypro.csv"))#
        p <- subset(x,inout(x[,c("fsc_small", "chl_small")],poly=poly.pro, bound=TRUE, quiet=TRUE))#
        opp[row.names(p),'pop'] <- "prochloro"#
#
      print("Pico")#
      x <- subset(opp, pop==0)#
      if(gate) { poly.pico <- getpoly(quiet=TRUE)#
                      write.csv(poly.pico,paste0(cruise,"data/", basename(file),"-polypico.csv"),quote=F, row.names=F )#
                    }#
      poly.pico <-  read.csv(paste0(cruise,"data/", basename(file),"-polypico.csv"))#
      l <- subset(x,inout(x[,c("fsc_small", "chl_small")],poly=poly.pico, bound=TRUE, quiet=TRUE))#
      opp[row.names(l),'pop'] <- "pico"#
    if(corr == 10000 | corr == -10000 | corr == 1 | corr == 2| corr == 3){#
          png(paste0(cruise,"data/", basename(file),"-offset",corr,".png"),width=9, height=12, unit='in', res=100)#
#
          if(nrow(opp)> 100000){opp. <- sample_n(opp, 100000)#
             } else opp. <- opp#
          par(mfrow=c(2,2))#
          plot.cytogram(aligned. ,  "fsc_small", "D1"); abline(b=notch.small.D1, a=offset.small.D1,col=2); abline(b=notch.large.D1, a=offset.large.D1,col=3); points(beads.fsc, beads.d1,pch=16, col=3)#
          plot.cytogram(aligned. , "fsc_small", "D2"); abline(b=notch.small.D2, a=offset.small.D2,col=2); abline(b=notch.large.D2, a=offset.large.D2,col=3); points(beads.fsc, beads.d2,pch=16, col=3)#
          plot.vct.cytogram(opp. , "fsc_small", "pe")#
          plot.vct.cytogram(opp. , "fsc_small", "chl_small")#
#
          dev.off()#
      }#
#
      n.opp <- nrow(opp)#
      n.opp. <- nrow(opp.)#
      n.evt <- nrow(evt)#
      n.evt. <- nrow(evt.)#
      beads <- nrow(b)#
      syn <- nrow(s)#
      pro <- nrow(p)#
      pico <- nrow(l)#
      filename <- basename(file)#
      if(cruise == 'MBARI1' | cruise == 'DeepDOM') filename <- paste(basename(dirname(file)),basename(file),sep="/")#
#
      all <- data.frame(cbind(file=filename, n.opp, n.opp., n.evt, n.evt., beads, pro, syn, pico, offset.small.D1, offset.large.D1,offset.small.D2, offset.large.D2, width, corr))#
#
      ALL <- rbind(ALL, all)#
#
    }#
  }#
#
write.csv(ALL, paste0(cruise,"data/seaflow-summary.csv"), quote=F, row.names=F)#
}
###################
### 2. SUMMARY ####
###################
library(lattice)#
library(lmodel2)#
#
setwd("~/Documents/DATA/Codes/seaflow-virtualcore/2.cruise_calibration/")#
#
allcruises <- c("SCOPE6", "DeepDOM", "MBARI1","Gradient1")#
cruise <- allcruises[1]#
DF <- NULL#
for(cruise in allcruises){#
#
print(cruise)#
#
### SFL + INFLUX#
if(cruise == 'DeepDOM'){sfl <- read.csv(paste0(cruise,"data/sfl.csv"))#
                        sfl$date <- as.POSIXct(sfl$date, format = "%FT%T", tz = "GMT")#
                      influx <- read.delim(paste0(cruise,"data/surface_samples_metadata.tab"))#
                        influx$time <- as.POSIXct(influx$Date.Time, format="%m/%d/%y %H:%M", tz="GMT")#
                        }#
if(cruise == 'Gradient1'){sfl <- read.csv(paste0(cruise,"data/sfl.csv"))#
                            sfl$date <- as.POSIXct(sfl$date, format = "%FT%T", tz = "GMT")#
                            sfl$file <- basename(as.character(sfl$file))#
                          influx <- read.csv(paste0(cruise,"data/all_station_curated.csv"))#
                            influx$time_HST <- as.POSIXct(influx$time_HST, format="%m/%d/%y %H:%M", tz="HST")#
                            influx <- influx[order(influx$time_HST), ]#
                            influx <- subset(influx, Depth_m < 16)#
                            pro <- subset(influx, population == 'prochloro')#
                            syn <- subset(influx, population == 'synecho')#
                            picoeuk <- subset(influx, population == 'picoeuk')#
                          influx <- data.frame(cbind(time=pro$time_HST, pro=pro$abundance, syn=syn$abundance, pico=picoeuk$abundance))#
                            influx$time <- as.POSIXct(influx$time, origin='1970-01-01',tz="GMT")#
                              }#
if(cruise == 'MBARI1'){sfl <- read.delim(paste0(cruise,"data/cruise.sfl"))#
                        sfl$date <- as.POSIXct(sfl$DATE, format = "%FT%T", tz = "GMT")#
                        sfl$file <- sfl[,"FILE"]#
                        sfl$flow_rate <- sfl[,"FLOW.RATE"]#
                      influx <- read.csv(paste0(cruise,"data/mbari_summary.csv"))#
                        id <- match(influx[,'file'],sfl[,"FILE"])#
                        influx$time <- sfl[id, 'date']#
                        influx$pro <- influx$pro / 1000#
                        influx$syn <- influx$syn / 1000#
                        influx$pico <- influx$picoeuks / 1000#
                          }#
if(cruise == 'SCOPE6'){sfl <- read.csv(paste0(cruise,"data/sfl.csv"))#
                        sfl$date <- as.POSIXct(sfl$date, format = "%FT%T", tz = "GMT")#
                        sfl$flow_rate <- median(sfl$flow_rate, na.rm=T)#
                        sfl$file <- basename(as.character(sfl$file))#
                      influx <- read.csv(paste0(cruise,"data/influx.csv"))#
                        influx$time <- as.POSIXct(influx$time, tz="GMT")#
                        pro <- subset(influx, pop == 'prochloro')#
                        syn <- subset(influx, pop == 'synecho')#
                        picoeuk <- subset(influx, pop == 'picoeuk')#
                        crocco <- subset(influx, pop == 'crocco')#
                          influx <- data.frame(cbind(time=pro$time, pro=pro$abundance, syn=syn$abundance, pico=picoeuk$abundance+crocco$abundance))#
                          influx$time <- as.POSIXct(influx$time, origin='1970-01-01',tz="GMT")#
                        }#
influx <- influx[order(influx$time), ]#
#
### SEAFLOW#
ALL <- read.csv(paste0(cruise,"data/seaflow-summary.csv"))#
#
if(cruise == "Gradient1") ALL <- ALL[!(ALL$file =="2016-04-26T15-07-38-00-00"),]#
if(cruise == "DeepDOM") ALL <- ALL[!(ALL$file =="2013_094/321.evt" | ALL$file=="2013_124/409.evt"),]#
#
  ALL$cruise <- cruise#
  id2 <- match(ALL[,'file'],as.character(sfl[,"file"]))#
  ALL$time <- sfl[id2, 'date'] # add time#
    ALL <- ALL[order(ALL$time), ]#
  ALL$fr <- sfl[id2, 'flow_rate'] # add flow rate#
#
  # add abundance from INFLUX#
  id <- findInterval(ALL$time,influx$time)#
  if(cruise =="DeepDOM"| cruise == "Gradient1") id <- id +1#
  for (phyto in c('pro','syn','pico'))   ALL[,paste0(phyto,'.influx')] <- influx[id,phyto]#
  ############### TEST different VC method ####################################
  ALL$vc1 <- 3*ALL[,'fr']*ALL[,'n.opp']/ALL[,'n.evt'] # calculate virtual core v1#
  ALL$vc2 <- 3*ALL[,'fr']*ALL[,'n.opp']/ALL[,'n.evt.'] # calculate virtual core v2#
  ALL$vc3 <- 3*ALL[,'fr']*ALL[,'n.opp.']/ALL[,'n.evt'] # calculate virtual core v3#
  ALL$vc4 <- 3*ALL[,'fr']*ALL[,'n.opp.']/ALL[,'n.evt.'] # calculate virtual core v4#
  # calculate abundance from Seaflow#
  for (phyto in c('pro','syn','pico')){#
      ALL[,paste0(phyto,'.seaflow.each1')] <- ALL[,phyto] / ALL$vc1#
      ALL[,paste0(phyto,'.seaflow.median1')] <- ALL[,phyto] / median(ALL$vc1)#
      ALL[,paste0(phyto,'.seaflow.each2')] <- ALL[,phyto] / ALL$vc2#
      ALL[,paste0(phyto,'.seaflow.median2')] <- ALL[,phyto] / median(ALL$vc2)#
      ALL[,paste0(phyto,'.seaflow.each3')] <- ALL[,phyto] / ALL$vc3#
      ALL[,paste0(phyto,'.seaflow.median3')] <- ALL[,phyto] / median(ALL$vc3)#
      ALL[,paste0(phyto,'.seaflow.each4')] <- ALL[,phyto] / ALL$vc4#
      ALL[,paste0(phyto,'.seaflow.median4')] <- ALL[,phyto] / median(ALL$vc4)#
      }#
#
          # par(mfrow=c(3,1),cex=1.2)#
          # for (phyto in c('pro','syn','pico')){#
          #         plot(ALL[,'time'],ALL[,paste0(phyto,'.influx')],ylim=c(0,2*max(ALL[,paste0(phyto,'.influx')])),type='o', ylab="abundance", xlab=NA, main=paste(phyto))#
          #         for(s in 1:4){#
          #           points(ALL[,'time'],ALL[,paste0(phyto,'.seaflow.each',s)],col=s)#
          #           points(ALL[,'time'],ALL[,paste0(phyto,'.seaflow.median',s)],col=s, pch=2)#
          #           }#
          #         }#
#
    # calculate error between seaflow-based and influx-based abundance#
    for (phyto in c('pro','syn','pico')){#
      for(s in 1:4){#
        ALL[,paste0(phyto,".diff.each",s)] <- abs(ALL[,paste0(phyto,'.seaflow.each',s)] - ALL[,paste0(phyto,'.influx')]) / ALL[,paste0(phyto,'.influx')]#
        ALL[,paste0(phyto,".diff.median",s)] <- abs(ALL[,paste0(phyto,'.seaflow.median',s)] -ALL[,paste0(phyto,'.influx')]) / ALL[,paste0(phyto,'.influx')]#
            }#
      }#
#
          # par(mfrow=c(3,1),cex=1.2)#
          # for (phyto in c('pro','syn','pico')){#
          #         plot(ALL[,'time'],rep(0, nrow(ALL)),ylim=c(0,1),type='l', ylab="Diff", xlab=NA, main=paste(phyto))#
          #         for(s in 1:4){#
          #           points(ALL[,'time'],ALL[,paste0(phyto,'.diff.each',s)],col=s)#
          #           points(ALL[,'time'],ALL[,paste0(phyto,'.diff.median',s)],col=s, pch=2)#
          #           }#
          #         }#
    DF <- rbind(DF,ALL)#
#
  }#
write.csv(DF,paste0("SeaflowInflux_comparison.csv"), quote=F, row.names=F)
###################
### 3. BEST VC ####
###################
setwd("~/Documents/DATA/Codes/seaflow-virtualcore/2.cruise_calibration/")#
DF <- read.csv("SeaflowInflux_comparison.csv")#
#
DF$time <- as.POSIXct(DF$time, tz='GMT')#
DF.a <- aggregate(DF, by=list(DF$cruise, DF$corr), mean)#
DF.a$cruise <- DF.a$Group.1#
#
# add a color for each cruise#
i <- 1#
for(cruise in unique(DF$cruise)){#
    DF[which(DF$cruise == cruise),'col.cruise'] <- i#
    i <- i + 1#
  }#
VC <- NULL#
par(mfrow=c(4,3),cex=1.2, pty='m')#
for(c in unique(DF$cruise)){#
  print(c)#
    df <- subset(DF.a, cruise == c)#
    for (phyto in c('pro','syn','pico')){#
      plot(df$corr, rep(0, nrow(df)), pch=NA ,ylim=c(0,2),xlab='offset',ylab='Diff',main=paste(phyto, c))#
      for(s in 1:4){#
        points(df$corr, df[,paste0(phyto, ".diff.each",s)],col=s)#
        points(df$corr, df[,paste0(phyto, ".diff.median",s)],col=s,pch=3)#
        each <- mean(df[,paste0(phyto, ".diff.each",s)])#
        median <- mean(df[,paste0(phyto, ".diff.median",s)])#
        vc <- data.frame(cbind(each, median))#
        vc$cruise <- c#
        vc$phyto <- phyto#
        vc$vc.method <- s#
        VC <- rbind(VC, vc)#
        }#
    }#
  }#
   met <- aggregate(VC, by=list(VC$vc.method, VC$phyto), mean)#
   best.vc.method <- unique(c(met[which(met$each == min(met$each)), "vc.method"], met[which(met$median == min(met$median)), "vc.method"]))#
   print(paste("best VC method is:",best.vc.method))
###################
### 3. BEST VC ####
###################
setwd("~/Documents/DATA/Codes/seaflow-virtualcore/2.cruise_calibration/")#
DF <- read.csv("SeaflowInflux_comparison.csv")#
#
DF$time <- as.POSIXct(DF$time, tz='GMT')#
DF.a <- aggregate(DF, by=list(DF$cruise, DF$corr), mean)#
DF.a$cruise <- DF.a$Group.1#
#
# add a color for each cruise#
i <- 1#
for(cruise in unique(DF$cruise)){#
    DF[which(DF$cruise == cruise),'col.cruise'] <- i#
    i <- i + 1#
  }#
VC <- NULL#
par(mfrow=c(4,3),cex=1.2, pty='m')#
for(c in unique(DF$cruise)){#
  print(c)#
    df <- subset(DF.a, cruise == c)#
    for (phyto in c('pro','syn','pico')){#
      plot(df$corr, rep(0, nrow(df)), pch=NA ,ylim=c(0,2),xlab='offset',ylab='Diff',main=paste(phyto, c))#
      for(s in 1:4){#
        points(df$corr, df[,paste0(phyto, ".diff.each",s)],col=s)#
        points(df$corr, df[,paste0(phyto, ".diff.median",s)],col=s,pch=3)#
        each <- mean(df[,paste0(phyto, ".diff.each",s)])#
        median <- mean(df[,paste0(phyto, ".diff.median",s)])#
        vc <- data.frame(cbind(each, median))#
        vc$cruise <- c#
        vc$phyto <- phyto#
        vc$vc.method <- s#
        VC <- rbind(VC, vc)#
        }#
    }#
  }#
   met <- aggregate(VC, by=list(VC$vc.method, VC$phyto), mean)#
   best.vc.method <- unique(c(met[which(met$each == min(met$each)), "vc.method"], met[which(met$median == min(met$median)), "vc.method"]))#
   print(paste("best VC method is:",best.vc.method))
library(scales)#
#
s <- best.vc.method#
REG <- NULL#
for(offset in unique(DF$corr)){#
  df <- subset(DF, corr==offset)#
  reg.pro <- lm(df[,paste0("pro.seaflow.each",s)] ~ pro.influx, data=df)#
  reg.syn <- lm(df[,paste0("syn.seaflow.median",s)] ~ syn.influx, data=df)#
  reg.pico <- lm(df[,paste0("pico.seaflow.median",s)] ~ pico.influx, data=df)#
  reg <- data.frame(cbind(offset, reg.pro=reg.pro$coefficient[2], reg.syn=reg.syn$coefficient[2], reg.pico=reg.pico$coefficient[2]))#
  REG <- rbind(REG, reg)#
}#
REG$reg.all <- rowMeans(abs(REG[,c("reg.pro", "reg.syn", "reg.pico")]-1))#
best.offset <- REG[which(REG$reg.all == min(REG$reg.all)),'offset']#
print(paste("best OFFET is:",best.offset))
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==0)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==1)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==2)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==3)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==2)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
REG
VC
head(DF)
head(DF,15)
DF$offset.small.d1
DF$offset.small.D1
dd <- subset(DF, corr ==0)
head(dd,20)
dd$offset.small.D1
tail(dd,20)
###################
### 3. BEST VC ####
###################
setwd("~/Documents/DATA/Codes/seaflow-virtualcore/2.cruise_calibration/")#
DF <- read.csv("SeaflowInflux_comparison.csv")#
#
DF$time <- as.POSIXct(DF$time, tz='GMT')#
DF.a <- aggregate(DF, by=list(DF$cruise, DF$corr), mean)#
DF.a$cruise <- DF.a$Group.1#
#
# add a color for each cruise#
i <- 1#
for(cruise in unique(DF$cruise)){#
    DF[which(DF$cruise == cruise),'col.cruise'] <- i#
    i <- i + 1#
  }#
VC <- NULL#
par(mfrow=c(4,3),cex=1.2, pty='m')#
for(c in unique(DF$cruise)){#
  print(c)#
    df <- subset(DF.a, cruise == c)#
    for (phyto in c('pro','syn','pico')){#
      plot(df$corr, rep(0, nrow(df)), pch=NA ,ylim=c(0,2),xlab='offset',ylab='Diff',main=paste(phyto, c))#
      for(s in 1:4){#
        points(df$corr, df[,paste0(phyto, ".diff.each",s)],col=s)#
        points(df$corr, df[,paste0(phyto, ".diff.median",s)],col=s,pch=3)#
        each <- mean(df[,paste0(phyto, ".diff.each",s)])#
        median <- mean(df[,paste0(phyto, ".diff.median",s)])#
        vc <- data.frame(cbind(each, median))#
        vc$cruise <- c#
        vc$phyto <- phyto#
        vc$vc.method <- s#
        VC <- rbind(VC, vc)#
        }#
    }#
  }#
   met <- aggregate(VC, by=list(VC$vc.method, VC$phyto), mean)#
   best.vc.method <- unique(c(met[which(met$each == min(met$each)), "vc.method"], met[which(met$median == min(met$median)), "vc.method"]))#
   print(paste("best VC method is:",best.vc.method))
library(scales)#
#
s <- best.vc.method#
REG <- NULL#
for(offset in unique(DF$corr)){#
  df <- subset(DF, corr==offset)#
  reg.pro <- lm(df[,paste0("pro.seaflow.each",s)] ~ pro.influx, data=df)#
  reg.syn <- lm(df[,paste0("syn.seaflow.median",s)] ~ syn.influx, data=df)#
  reg.pico <- lm(df[,paste0("pico.seaflow.median",s)] ~ pico.influx, data=df)#
  reg <- data.frame(cbind(offset, reg.pro=reg.pro$coefficient[2], reg.syn=reg.syn$coefficient[2], reg.pico=reg.pico$coefficient[2]))#
  REG <- rbind(REG, reg)#
}#
REG$reg.all <- rowMeans(abs(REG[,c("reg.pro", "reg.syn", "reg.pico")]-1))#
best.offset <- REG[which(REG$reg.all == min(REG$reg.all)),'offset']#
print(paste("best OFFET is:",best.offset))
REG
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==2)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==1)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==2)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==3)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==2)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==3)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
png(paste0("SeaFlowInflux-comparison.png"),width=12, height=15, unit='in', res=500)#
#
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)#
#
dev.off()
df3 <- subset(DF, corr==3)#
df2 <- subset(DF, corr==2)
plot(df2[,"pro.seaflow.each2"],df3[,"pro.seaflow.each2"] )
plot(df2[,"syn.seaflow.median2"],df3[,"syn.seaflow.median2"] )
plot(df2[,"pico.seaflow.median2"],df3[,"pico.seaflow.median2"] )
REG
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)]/2, xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)]/2, log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)]/2, xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)]/2, log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)]/2, xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)]/2,log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)
png(paste0("SeaFlowInflux-comparison.png"),width=12, height=15, unit='in', res=500)#
#
t <- 0.4#
par(mfrow=c(3,2), pty='s',cex=1.2)#
  df <- subset(DF, corr==best.offset)#
  plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
    legend('topleft',legend=unique(df$cruise),pt.bg=alpha(unique(df$col.cruise),t), pch=21,bty='n',cex=0.8)#
    plot(df[,"pro.influx"], df[,paste0("pro.seaflow.each",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Prochlorococcus",ylim=c(1,370),xlim=c(1,370)); abline(b=1, a=0, lty=2)#
  plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0,150),ylim=c(0,150)); abline(b=1, a=0, lty=2)#
    plot(df[,"syn.influx"], df[,paste0("syn.seaflow.median",s)], log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Synechococcus",xlim=c(0.1,150),ylim=c(0.1,150)); abline(b=1, a=0, lty=2)#
  plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)], xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0,50),ylim=c(0,50)); abline(b=1, a=0, lty=2)#
    plot(df[,"pico.influx"], df[,paste0("pico.seaflow.median",s)],log='xy', xlab="Influx", ylab='SeaFlow', pch=21, bg=alpha(df$col.cruise,t), main="Picoeukaryotes",xlim=c(0.1,50),ylim=c(0.1,50)); abline(b=1, a=0, lty=2)#
#
dev.off()
#' Plot helpful cytograms for estimating the D1, D2 and FSC coordinates of the inflection point (corresponds to location of 1µm beads).#
#'#
#' @param dataframe containing EVT data.#
#' @return D1, D2 and fsc values of presumed 1 µm beads#
#' @export#
inflection.point <- function(DF){#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
  par(mfrow=c(1,3),pty='s')#
#
  plot.cytogram(DF, "fsc_small", "pe")#
    poly.beads <- getpoly(quiet=TRUE)#
    b <- subset(DF,inout(DF[,c("fsc_small", "pe")],poly=poly.beads, bound=TRUE, quiet=TRUE))#
#
  plot.cytogram(DF, "fsc_small", "D1");points(b$fsc_small, b$D1,col=2, pch = 16, cex = 0.5)#
      polyd1 <- getpoly(quiet=TRUE)#
#
  plot.cytogram(DF, "fsc_small", "D2");points(b$fsc_small, b$D2,col=2,pch = 16, cex = 0.5)#
      polyd2 <- getpoly(quiet=TRUE)#
#
      fsc <- round(mean(c(polyd1[,1], polyd2[,1])))#
      d1 <- round(mean(polyd1[,2]))#
      d2 <- round(mean(polyd2[,2]))#
      inflection <- data.frame(fsc, d1, d2)#
#
  par(def.par)#
#
  return(inflection)#
}#
#
#' Get Notch and Offset values for Filter.notch function.#
#'#
#' @param inst Instrument serial number#
#' @param fsc Small forward scatter value of 1 µm beads#
#' @param d1 D1 value of 1 µm beads#
#' @param d2 D2 value of 1 µm beads#
#' @param slopes User-supplied filter slope CSV file, overriding the installed#
#'   default file.#
#' @return Data frame with filtering parameters for 2.5, 50.0, 97.5 quantiles#
#' @examples#
#' \dontrun{#
#' filt <- create.filter.params(inst, fsc, d1, d2)#
#' }#
#' @export#
create.filter.params <- function(inst, fsc, d1, d2, slope.file=NULL) {#
  # Rename to get correct dataframe headers#
  beads.fsc.small <- as.numeric(fsc)#
  beads.D1 <- as.numeric(d1)#
  beads.D2 <- as.numeric(d2)#
#
  width <- 2500#
#
  if (is.null(slope.file)) {#
    slope.file <- system.file("filter", "seaflow_filter_slopes.csv",package='popcycle')#
  }#
  slopes <- read.csv(slope.file)#
#
  filter.params <- data.frame()#
  headers <- c("quantile", "beads.fsc.small",#
               "beads.D1", "beads.D2", "width",#
               "notch.small.D1", "notch.small.D2",#
               "notch.large.D1", "notch.large.D2",#
               "offset.small.D1", "offset.small.D2",#
               "offset.large.D1", "offset.large.D2")#
#
  for (quantile in QUANTILES) {#
    if (quantile == 2.5) {#
      suffix <- "_2.5"#
    } else if (quantile == 97.5) {#
      suffix <- "_97.5"#
    } else if (quantile == 50.0) {#
      suffix <- ""#
    }#
#
    notch.small.D1 <- slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)]#
    notch.small.D2 <- slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)]#
    notch.large.D1 <- slopes[slopes$ins== inst, paste0('notch.large.D1', suffix)]#
    notch.large.D2 <- slopes[slopes$ins== inst, paste0('notch.large.D2', suffix)]#
    offset.small.D1 <- round(beads.D1 - notch.small.D1 * beads.fsc.small)#
    offset.small.D2 <- round(beads.D1 - notch.small.D2 * beads.fsc.small)#
    offset.large.D1 <- round(beads.D1 - notch.large.D1 * beads.fsc.small)#
    offset.large.D2 <- round(beads.D2 - notch.large.D2 * beads.fsc.small)#
#
    if(notch.small.D1 < 0 | notch.small.D2 < 0){#
      notch.small.D1 <- beads.D1/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)] / slopes[slopes$ins== inst, 'notch.small.D1']#
      notch.small.D2 <- beads.D2/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)] / slopes[slopes$ins== inst, 'notch.small.D2']#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      }#
#
    newrow <- data.frame(quantile, beads.fsc.small,#
                         beads.D1, beads.D2, width,#
                         notch.small.D1, notch.small.D2,#
                         notch.large.D1, notch.large.D2,#
                         offset.small.D1, offset.small.D2,#
                         offset.large.D1, offset.large.D2,#
                         stringsAsFactors=FALSE)#
    names(newrow) <- headers#
    filter.params <- rbind(filter.params, newrow)#
  }#
#
  return(filter.params)#
}#
#
#' Filter EVT particles with a generic filter function.#
#'#
#' @param evt EVT data frame.#
#' @param filter.func Filtering function.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.evt(evt, filter.notch, filter.params)#
#' }#
#' @export#
filter.evt <- function(evt, filter.func, ...) {#
  filt <- filter.func(evt, ...)#
#
  # SANITY CHECKS#
  # need same columns for opp#
  if (!all(names(evt) == names(filt$opp))) {#
    stop('Filtering function produced OPP with different columns')#
  }#
#
  return (filt)#
}#
#
#' Filter EVT particles.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.notch(evt, params)#
#' }#
#' @export#
filter.notch <- function(evt, filter.params) {#
  width <- as.numeric(filter.params$width)#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # Check for empty evt data frame.  If empty return empty opp data frame.#
  if (nrow(evt) == 0) {#
    return(list("opp"=data.frame(c())))#
  }#
#
  # linearize the LOG transformed data#
  lin <- FALSE#
  id <- which(colnames(evt) == "pulse_width" | colnames(evt) == "time" | colnames(evt) =="pop")#
  if (!any(max(evt[,-c(id)]) > 10^3.5)) {#
    evt <- untransformData(evt)#
    lin <- TRUE#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2)#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D + notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
#
      if(lin) opp <- transformData(opp)#
#
  params = list("width"=width,#
                "notch.small.D1"= notch.small.D1,"notch.small.D2"= notch.small.D2,#
                "notch.large.D1"= notch.large.D1,"notch.large.D2"= notch.large.D2,#
                "offset.small.D1"= offset.small.D1,"offset.small.D2"= offset.small.D2,#
                "offset.large.D1"= offset.large.D1,"offset.large.D2"= offset.large.D2)#
  return(list("opp"=opp, "params"=params))#
}#
#
#' Plot helpful cytograms for exploring filtering parameters.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram <- function(evt, filter.params) {#
  width <- 2500#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # linearize the LOG transformed data#
  id <- which(colnames(evt) == "fsc_small" | colnames(evt) == "chl_small" | colnames(evt) =="pe" | colnames(evt) =="fsc_perp" | colnames(evt) =="D1" | colnames(evt) =="D2")#
  if (!any(max(evt[,c(id)]) > 10^3.5)) {#
    evt[,c(id)] <- (log10(evt[,c(id)])/3.5)*2^16#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2), with Correction for the difference of sensitivity between D1 and D2#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D * notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
  #################
  ### PLOTTING ####
  #################
  cols <- colorRampPalette(c("blue4","royalblue4","deepskyblue3", "seagreen3", "yellow", "orangered2","darkred"))#
  percent.opp <- round(100*nrow(opp)/nrow(evt.),2)#
  percent.noise <- round(100-100*nrow(evt.)/nrow(evt),0)#
#
  if(nrow(evt.) > 10000)  evt. <- evt.[round(seq(1,nrow(evt.), length.out=10000)),]#
  if(nrow(aligned) > 10000)  aligned <- aligned[round(seq(1,nrow(aligned), length.out=10000)),]#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
#
  par(mfrow=c(2,3),pty='s')#
#
  plot.cytogram(evt., "D1", "D2")#
  mtext("Alignment", side=3, line=3, font=2, col=2)#
  abline(b=1, a=width, col='red',lwd=2)#
  abline(b=1, a=- width, col='red',lwd=2)#
  plotrix:::draw.circle(0,0, radius=2000, border=2, lwd=2)#
  mtext(paste0("Noise = ", percent.noise, "%" ), side=3, line=2, font=2)#
  mtext(paste("Width=", width),side=3, line=1,font=2)#
#
  plot.cytogram(aligned, "fsc_small", "D1")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D1, a=offset.small.D1,col=2)#
  abline(b=notch.large.D1, a=offset.large.D1,col=3)#
#
  plot.cytogram(aligned, "fsc_small", "D2")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D2, a=offset.small.D2,col=2)#
  abline(b=notch.large.D2, a=offset.large.D2,col=3)#
#
  plot.cytogram(opp, "fsc_small", "pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "fsc_small","chl_small")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "chl_small","pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  mtext(paste("OPP =", percent.opp,"% EVT"), outer=T,side=1, line=-2,font=2,col=1)#
#
  par(def.par)#
}#
#
#' Plot helpful cytograms for exploring filtering parameters for one file.#
#'#
#' @param evt.dir EVT file directory.#
#' @param file.name File name with julian day directory.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram.by.file <- function(evt.dir, file.name, filter.params) {#
  file.name <- clean.file.path(file.name)#
  evt <- readSeaflow(file.path(evt.dir, file.name))#
  plot.filter.cytogram(evt, filter.params)#
}#
#' Filter a list of EVT files.#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param evt.dir EVT file directory.#
#' @param evt.files List of EVT files to filter. Include julian day directory.#
#' @param opp.dir OPP file output directory.#
#' @param filter.id Optionally provide the ID for filter parameters. If NULL,#
#'   the most recently saved filter parameters will be used.#
#' @return None#
#' @examples#
#' \dontrun{#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir)#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir,#
#'                  "d3afb1ea-ad20-46cf-866d-869300fe17f4")#
#' }#
#' @export#
filter.evt.files <- function(db, evt.dir, evt.files, opp.dir,#
                             filter.id=NULL) {#
  # Get notch and width to use from params file#
  # Return empty data frame on warning or error#
  if (is.null(filter.id)) {#
    filter.params <- get.filter.params.latest(db)#
  } else {#
    filter.params <- get.filter.params.by.id(db, filter.id)#
  }#
#
  if (nrow(filter.params) == 0) {#
    stop("No filter parameters defined")#
  }#
#
  i <- 0#
  for (evt.file in evt.files) {#
    message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
#
    # Read EVT file#
    # Create empty data frame on warning or error#
    evt <- tryCatch({#
      path <- file.path(evt.dir, evt.file)#
      readSeaflow(path, transform=FALSE)#
    }, warnings = function(err) {#
      print(err)#
      return(data.frame())#
    }, error = function(err) {#
      print(err)#
      return(data.frame())#
    })#
    evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
    evt_count <- nrow(evt.)#
    all_count <- nrow(evt)#
#
    # Delete all versions of this OPP file#
    delete.opp.by.file(opp.dir, evt.file)#
#
    for (quantile in QUANTILES) {#
      p <- filter.params[filter.params$quantile == quantile, ]#
      # Filter EVT to OPP#
      # Return empty data frame on warning or error#
      result <- tryCatch({#
        filter.evt(evt, filter.notch, p)#
      }, warnings = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      }, error = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      })#
#
      # Save OPP data#
      if (nrow(result$opp) > 0) {#
        save.opp.stats(db, evt.file, all_count, evt_count,#
                       result$opp, p$id, quantile)#
        save.opp.file(result$opp, opp.dir, evt.file, quantile)#
      }#
    }#
#
    i <-  i + 1#
    flush.console()#
  }#
  message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
  flush.console()#
}#
#
#' Filter a directory of EVT files using seaflowpy_filter#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param cruise.name Cruise name.#
#' @param evt.dir EVT file directory.#
#' @param opp.dir OPP file output directory.#
#' @param process.count Number of processes to start for filtering.#
#' @param limit Only process up to this many files.#
#' @param resolution Progress update resolution in \%.#
#' @param width,notch.small.D1, notch.small.D2, notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2, offset.large.D1, offset.large.D2 Filter parameters.#
#' @return None#
#' @examples#
#' \dontrun{#
#' seaflowpy_filter("testcruise.db", "testcruise", "./testcruise", "./testcruise_opp")#
#' }#
#' @export#
seaflowpy_filter <- function(db, cruise.name, evt.dir, opp.dir, process.count=1, twopass=FALSE,#
                             limit=NULL, resolution=NULL, width=NULL,#
                             notch.small.D1=NULL, notch.small.D2=NULL,#
                             notch.large.D1=NULL, notch.large.D2=NULL,#
                             offset.small.D1=NULL, offset.small.D2=NULL,#
                             offset.large.D1=NULL, offset.large.D2=NULL){#
#
  # First check for seaflowpy_filter in PATH#
  result <- tryCatch(#
    {#
      system2("bash", c("-lc", "'seaflowpy_filter --version'"), stdout=TRUE, stderr=TRUE)#
    },#
    warning=function(w) {#
      invisible(w)#
    },#
    error=function(e) {#
      return("system2error")#
    }#
  )#
  if (result == "system2error") {#
    warning("Could not run seaflowpy_filter")#
    return()#
  }#
#
  cmd <- paste0("'seaflowpy_filter ", '-c "', cruise.name, '" -e "',#
                normalizePath(evt.dir), '" -o "',  normalizePath(opp.dir),#
                '" -d "', normalizePath(db), '"')#
  if (! is.null(process.count)) {#
    cmd <- paste0(cmd, " -p ", process.count)#
  }#
  if (! is.null(resolution)) {#
    cmd <- paste0(cmd, " -r ", resolution)#
  }#
  if (! is.null(limit)) {#
    cmd <- paste0(cmd, " -l ", limit)#
  }#
  if (! is.null(width)) {#
    cmd <- paste0(cmd, " --width ", width)#
  }#
  if (! is.null(notch.small.D1)) {#
    cmd <- paste0(cmd, " --notch.small.D1 ", notch.small.D1)#
  }#
  if (! is.null(notch.small.D2)) {#
    cmd <- paste0(cmd, " --notch.small.D2 ", notch.small.D2)#
  }#
  if (! is.null(notch.largel.D1)) {#
    cmd <- paste0(cmd, " --notch.large.D1 ", notch.large.D1)#
  }#
  if (! is.null(notch.large.D2)) {#
    cmd <- paste0(cmd, " --notch.large.D2 ", notch.large.D2)#
  }#
  if (! is.null(offset.small.D1)) {#
    cmd <- paste0(cmd, " --offset.small.D1 ", offset.small.D1)#
  }#
  if (! is.null(offset.small.D2)) {#
    cmd <- paste0(cmd, " --offset.small.D2 ", offset.small.D2)#
  }#
  if (! is.null(offset.largel.D1)) {#
    cmd <- paste0(cmd, " --offset.large.D1 ", offset.large.D1)#
  }#
  if (! is.null(offset.large.D2)) {#
    cmd <- paste0(cmd, " --offset.large.D2 ", offset.large.D2)#
  }#
  cmd <- paste0(cmd, "'")#
  system2("bash", c("-lc", cmd))#
}
cruise <- cruise.list[52]#
  print(cruise)#
  DF <- read.csv(paste0(cruise,"/concatenated_EVT.csv"))#
#
  # Gates beads to find intersections of the two slopes used for OPP filtration#
  ip <- inflection.point(DF)
x <- gs_title("SeaFlow\ instrument\ log", verbose = TRUE)#
list <- gs_read(x)#
cruise.list <- list$cruise
library(popcycle)#
library(aws.s3)#
library(googlesheets)#
#path to Git repo#
setwd("~/Documents/DATA/Codes/seaflow-filter")#
#################################################
### Copy EVT files from DAT to local machine ####
#################################################
# link to EVT folder containing EVT files use with this script:#
#
dat://2b03e08a5cc4b4cc430d5a355115c6a1597ca6d6ccfc9778f1fb5b545a600deb#
#
#Path to the raw data (DAT)#
path.to.data <- "~/Documents/DATA/Codes/seaflow-filter/seaflow-filter-data/"#
#####################################
### CREATE concatenated EVT file ####
#####################################
x <- gs_title("SeaFlow\ instrument\ log", verbose = TRUE)#
list <- gs_read(x)#
cruise.list <- list$cruise
cruise <- cruise.list[52]#
  print(cruise)#
  DF <- read.csv(paste0(cruise,"/concatenated_EVT.csv"))#
#
  # Gates beads to find intersections of the two slopes used for OPP filtration#
  ip <- inflection.point(DF)
# check OPP filtration#
  inst <- unlist(list(list[which(list$cruise == cruise),'instrument']))#
  params <- create.filter.params(inst, fsc=ip$fsc, d1=ip$d1, d2=ip$d2)[2,]#
  evt <- readSeaflow(evt.list[80],transform=F)#
  plot.filter.cytogram(evt, params)
QUANTILES <- c(2.5, 50.0, 97.5)
params <- create.filter.params(inst, fsc=ip$fsc, d1=ip$d1, d2=ip$d2)[2,]
plot.filter.cytogram(evt, params)
#' Plot helpful cytograms for estimating the D1, D2 and FSC coordinates of the inflection point (corresponds to location of 1µm beads).#
#'#
#' @param dataframe containing EVT data.#
#' @return D1, D2 and fsc values of presumed 1 µm beads#
#' @export#
inflection.point <- function(DF){#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
  par(mfrow=c(1,3),pty='s')#
#
  plot.cytogram(DF, "fsc_small", "pe")#
    poly.beads <- getpoly(quiet=TRUE)#
    b <- subset(DF,inout(DF[,c("fsc_small", "pe")],poly=poly.beads, bound=TRUE, quiet=TRUE))#
#
  plot.cytogram(DF, "fsc_small", "D1");points(b$fsc_small, b$D1,col=2, pch = 16, cex = 0.5)#
      polyd1 <- getpoly(quiet=TRUE)#
#
  plot.cytogram(DF, "fsc_small", "D2");points(b$fsc_small, b$D2,col=2,pch = 16, cex = 0.5)#
      polyd2 <- getpoly(quiet=TRUE)#
#
      fsc <- round(mean(c(polyd1[,1], polyd2[,1])))#
      d1 <- round(mean(polyd1[,2]))#
      d2 <- round(mean(polyd2[,2]))#
      inflection <- data.frame(fsc, d1, d2)#
#
  par(def.par)#
#
  return(inflection)#
}#
#
#' Get Notch and Offset values for Filter.notch function.#
#'#
#' @param inst Instrument serial number#
#' @param fsc Small forward scatter value of 1 µm beads#
#' @param d1 D1 value of 1 µm beads#
#' @param d2 D2 value of 1 µm beads#
#' @param slopes User-supplied filter slope CSV file, overriding the installed#
#'   default file.#
#' @return Data frame with filtering parameters for 2.5, 50.0, 97.5 quantiles#
#' @examples#
#' \dontrun{#
#' filt <- create.filter.params(inst, fsc, d1, d2)#
#' }#
#' @export#
create.filter.params <- function(inst, fsc, d1, d2, slope.file=NULL) {#
  # Rename to get correct dataframe headers#
  beads.fsc.small <- as.numeric(fsc)#
  beads.D1 <- as.numeric(d1)#
  beads.D2 <- as.numeric(d2)#
#
  width <- 2500#
#
  if (is.null(slope.file)) {#
    slope.file <- system.file("filter", "seaflow_filter_slopes.csv",package='popcycle')#
  }#
  slopes <- read.csv(slope.file)#
#
  filter.params <- data.frame()#
  headers <- c("quantile", "beads.fsc.small",#
               "beads.D1", "beads.D2", "width",#
               "notch.small.D1", "notch.small.D2",#
               "notch.large.D1", "notch.large.D2",#
               "offset.small.D1", "offset.small.D2",#
               "offset.large.D1", "offset.large.D2")#
#
  for (quantile in QUANTILES) {#
    if (quantile == 2.5) {#
      suffix <- "_2.5"#
    } else if (quantile == 97.5) {#
      suffix <- "_97.5"#
    } else if (quantile == 50.0) {#
      suffix <- ""#
    }#
#
    notch.small.D1 <- slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)]#
    notch.small.D2 <- slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)]#
    notch.large.D1 <- slopes[slopes$ins== inst, paste0('notch.large.D1', suffix)]#
    notch.large.D2 <- slopes[slopes$ins== inst, paste0('notch.large.D2', suffix)]#
    offset.small.D1 <- round(beads.D1 - notch.small.D1 * beads.fsc.small)#
    offset.small.D2 <- round(beads.D1 - notch.small.D2 * beads.fsc.small)#
    offset.large.D1 <- round(beads.D1 - notch.large.D1 * beads.fsc.small)#
    offset.large.D2 <- round(beads.D2 - notch.large.D2 * beads.fsc.small)#
#
    if(notch.small.D1 < 0 | notch.small.D2 < 0){#
      notch.small.D1 <- beads.D1/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)] / slopes[slopes$ins== inst, 'notch.small.D1']#
      notch.small.D2 <- beads.D2/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)] / slopes[slopes$ins== inst, 'notch.small.D2']#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      }#
#
    newrow <- data.frame(quantile, beads.fsc.small,#
                         beads.D1, beads.D2, width,#
                         notch.small.D1, notch.small.D2,#
                         notch.large.D1, notch.large.D2,#
                         offset.small.D1, offset.small.D2,#
                         offset.large.D1, offset.large.D2,#
                         stringsAsFactors=FALSE)#
    names(newrow) <- headers#
    filter.params <- rbind(filter.params, newrow)#
  }#
#
  return(filter.params)#
}#
#
#' Filter EVT particles with a generic filter function.#
#'#
#' @param evt EVT data frame.#
#' @param filter.func Filtering function.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.evt(evt, filter.notch, filter.params)#
#' }#
#' @export#
filter.evt <- function(evt, filter.func, ...) {#
  filt <- filter.func(evt, ...)#
#
  # SANITY CHECKS#
  # need same columns for opp#
  if (!all(names(evt) == names(filt$opp))) {#
    stop('Filtering function produced OPP with different columns')#
  }#
#
  return (filt)#
}#
#
#' Filter EVT particles.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.notch(evt, params)#
#' }#
#' @export#
filter.notch <- function(evt, filter.params) {#
  width <- as.numeric(filter.params$width)#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # Check for empty evt data frame.  If empty return empty opp data frame.#
  if (nrow(evt) == 0) {#
    return(list("opp"=data.frame(c())))#
  }#
#
  # linearize the LOG transformed data#
  lin <- FALSE#
  id <- which(colnames(evt) == "pulse_width" | colnames(evt) == "time" | colnames(evt) =="pop")#
  if (!any(max(evt[,-c(id)]) > 10^3.5)) {#
    evt <- untransformData(evt)#
    lin <- TRUE#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2)#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D + notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
      if(lin) opp <- transformData(opp)#
#
  params = list("width"=width,#
                "notch.small.D1"= notch.small.D1,"notch.small.D2"= notch.small.D2,#
                "notch.large.D1"= notch.large.D1,"notch.large.D2"= notch.large.D2,#
                "offset.small.D1"= offset.small.D1,"offset.small.D2"= offset.small.D2,#
                "offset.large.D1"= offset.large.D1,"offset.large.D2"= offset.large.D2)#
  return(list("opp"=opp, "params"=params))#
}#
#
#' Plot helpful cytograms for exploring filtering parameters.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram <- function(evt, filter.params) {#
  width <- 2500#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # linearize the LOG transformed data#
  id <- which(colnames(evt) == "fsc_small" | colnames(evt) == "chl_small" | colnames(evt) =="pe" | colnames(evt) =="fsc_perp" | colnames(evt) =="D1" | colnames(evt) =="D2")#
  if (!any(max(evt[,c(id)]) > 10^3.5)) {#
    evt[,c(id)] <- (log10(evt[,c(id)])/3.5)*2^16#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2), with Correction for the difference of sensitivity between D1 and D2#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D * notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
  opp <- subset(opp != 0)  #
  #################
  ### PLOTTING ####
  #################
  cols <- colorRampPalette(c("blue4","royalblue4","deepskyblue3", "seagreen3", "yellow", "orangered2","darkred"))#
  percent.opp <- round(100*nrow(opp)/nrow(evt.),2)#
  percent.noise <- round(100-100*nrow(evt.)/nrow(evt),0)#
#
  if(nrow(evt.) > 10000)  evt. <- evt.[round(seq(1,nrow(evt.), length.out=10000)),]#
  if(nrow(aligned) > 10000)  aligned <- aligned[round(seq(1,nrow(aligned), length.out=10000)),]#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
#
  par(mfrow=c(2,3),pty='s')#
#
  plot.cytogram(evt., "D1", "D2")#
  mtext("Alignment", side=3, line=3, font=2, col=2)#
  abline(b=1, a=width, col='red',lwd=2)#
  abline(b=1, a=- width, col='red',lwd=2)#
  plotrix:::draw.circle(0,0, radius=2000, border=2, lwd=2)#
  mtext(paste0("Noise = ", percent.noise, "%" ), side=3, line=2, font=2)#
  mtext(paste("Width=", width),side=3, line=1,font=2)#
#
  plot.cytogram(aligned, "fsc_small", "D1")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D1, a=offset.small.D1,col=2)#
  abline(b=notch.large.D1, a=offset.large.D1,col=3)#
#
  plot.cytogram(aligned, "fsc_small", "D2")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D2, a=offset.small.D2,col=2)#
  abline(b=notch.large.D2, a=offset.large.D2,col=3)#
#
  plot.cytogram(opp, "fsc_small", "pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "fsc_small","chl_small")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "chl_small","pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  mtext(paste("OPP =", percent.opp,"% EVT"), outer=T,side=1, line=-2,font=2,col=1)#
#
  par(def.par)#
}#
#
#' Plot helpful cytograms for exploring filtering parameters for one file.#
#'#
#' @param evt.dir EVT file directory.#
#' @param file.name File name with julian day directory.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram.by.file <- function(evt.dir, file.name, filter.params) {#
  file.name <- clean.file.path(file.name)#
  evt <- readSeaflow(file.path(evt.dir, file.name))#
  plot.filter.cytogram(evt, filter.params)#
}#
#' Filter a list of EVT files.#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param evt.dir EVT file directory.#
#' @param evt.files List of EVT files to filter. Include julian day directory.#
#' @param opp.dir OPP file output directory.#
#' @param filter.id Optionally provide the ID for filter parameters. If NULL,#
#'   the most recently saved filter parameters will be used.#
#' @return None#
#' @examples#
#' \dontrun{#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir)#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir,#
#'                  "d3afb1ea-ad20-46cf-866d-869300fe17f4")#
#' }#
#' @export#
filter.evt.files <- function(db, evt.dir, evt.files, opp.dir,#
                             filter.id=NULL) {#
  # Get notch and width to use from params file#
  # Return empty data frame on warning or error#
  if (is.null(filter.id)) {#
    filter.params <- get.filter.params.latest(db)#
  } else {#
    filter.params <- get.filter.params.by.id(db, filter.id)#
  }#
#
  if (nrow(filter.params) == 0) {#
    stop("No filter parameters defined")#
  }#
#
  i <- 0#
  for (evt.file in evt.files) {#
    message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
#
    # Read EVT file#
    # Create empty data frame on warning or error#
    evt <- tryCatch({#
      path <- file.path(evt.dir, evt.file)#
      readSeaflow(path, transform=FALSE)#
    }, warnings = function(err) {#
      print(err)#
      return(data.frame())#
    }, error = function(err) {#
      print(err)#
      return(data.frame())#
    })#
    evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
    evt_count <- nrow(evt.)#
    all_count <- nrow(evt)#
#
    # Delete all versions of this OPP file#
    delete.opp.by.file(opp.dir, evt.file)#
#
    for (quantile in QUANTILES) {#
      p <- filter.params[filter.params$quantile == quantile, ]#
      # Filter EVT to OPP#
      # Return empty data frame on warning or error#
      result <- tryCatch({#
        filter.evt(evt, filter.notch, p)#
      }, warnings = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      }, error = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      })#
#
      # Save OPP data#
      if (nrow(result$opp) > 0) {#
        save.opp.stats(db, evt.file, all_count, evt_count,#
                       result$opp, p$id, quantile)#
        save.opp.file(result$opp, opp.dir, evt.file, quantile)#
      }#
    }#
#
    i <-  i + 1#
    flush.console()#
  }#
  message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
  flush.console()#
}#
#
#' Filter a directory of EVT files using seaflowpy_filter#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param cruise.name Cruise name.#
#' @param evt.dir EVT file directory.#
#' @param opp.dir OPP file output directory.#
#' @param process.count Number of processes to start for filtering.#
#' @param limit Only process up to this many files.#
#' @param resolution Progress update resolution in \%.#
#' @param width,notch.small.D1, notch.small.D2, notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2, offset.large.D1, offset.large.D2 Filter parameters.#
#' @return None#
#' @examples#
#' \dontrun{#
#' seaflowpy_filter("testcruise.db", "testcruise", "./testcruise", "./testcruise_opp")#
#' }#
#' @export#
seaflowpy_filter <- function(db, cruise.name, evt.dir, opp.dir, process.count=1, twopass=FALSE,#
                             limit=NULL, resolution=NULL, width=NULL,#
                             notch.small.D1=NULL, notch.small.D2=NULL,#
                             notch.large.D1=NULL, notch.large.D2=NULL,#
                             offset.small.D1=NULL, offset.small.D2=NULL,#
                             offset.large.D1=NULL, offset.large.D2=NULL){#
#
  # First check for seaflowpy_filter in PATH#
  result <- tryCatch(#
    {#
      system2("bash", c("-lc", "'seaflowpy_filter --version'"), stdout=TRUE, stderr=TRUE)#
    },#
    warning=function(w) {#
      invisible(w)#
    },#
    error=function(e) {#
      return("system2error")#
    }#
  )#
  if (result == "system2error") {#
    warning("Could not run seaflowpy_filter")#
    return()#
  }#
#
  cmd <- paste0("'seaflowpy_filter ", '-c "', cruise.name, '" -e "',#
                normalizePath(evt.dir), '" -o "',  normalizePath(opp.dir),#
                '" -d "', normalizePath(db), '"')#
  if (! is.null(process.count)) {#
    cmd <- paste0(cmd, " -p ", process.count)#
  }#
  if (! is.null(resolution)) {#
    cmd <- paste0(cmd, " -r ", resolution)#
  }#
  if (! is.null(limit)) {#
    cmd <- paste0(cmd, " -l ", limit)#
  }#
  if (! is.null(width)) {#
    cmd <- paste0(cmd, " --width ", width)#
  }#
  if (! is.null(notch.small.D1)) {#
    cmd <- paste0(cmd, " --notch.small.D1 ", notch.small.D1)#
  }#
  if (! is.null(notch.small.D2)) {#
    cmd <- paste0(cmd, " --notch.small.D2 ", notch.small.D2)#
  }#
  if (! is.null(notch.largel.D1)) {#
    cmd <- paste0(cmd, " --notch.large.D1 ", notch.large.D1)#
  }#
  if (! is.null(notch.large.D2)) {#
    cmd <- paste0(cmd, " --notch.large.D2 ", notch.large.D2)#
  }#
  if (! is.null(offset.small.D1)) {#
    cmd <- paste0(cmd, " --offset.small.D1 ", offset.small.D1)#
  }#
  if (! is.null(offset.small.D2)) {#
    cmd <- paste0(cmd, " --offset.small.D2 ", offset.small.D2)#
  }#
  if (! is.null(offset.largel.D1)) {#
    cmd <- paste0(cmd, " --offset.large.D1 ", offset.large.D1)#
  }#
  if (! is.null(offset.large.D2)) {#
    cmd <- paste0(cmd, " --offset.large.D2 ", offset.large.D2)#
  }#
  cmd <- paste0(cmd, "'")#
  system2("bash", c("-lc", cmd))#
}
opp <- subset(opp, fsc_small != 0)
#' Plot helpful cytograms for estimating the D1, D2 and FSC coordinates of the inflection point (corresponds to location of 1µm beads).#
#'#
#' @param dataframe containing EVT data.#
#' @return D1, D2 and fsc values of presumed 1 µm beads#
#' @export#
inflection.point <- function(DF){#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
  par(mfrow=c(1,3),pty='s')#
#
  plot.cytogram(DF, "fsc_small", "pe")#
    poly.beads <- getpoly(quiet=TRUE)#
    b <- subset(DF,inout(DF[,c("fsc_small", "pe")],poly=poly.beads, bound=TRUE, quiet=TRUE))#
#
  plot.cytogram(DF, "fsc_small", "D1");points(b$fsc_small, b$D1,col=2, pch = 16, cex = 0.5)#
      polyd1 <- getpoly(quiet=TRUE)#
#
  plot.cytogram(DF, "fsc_small", "D2");points(b$fsc_small, b$D2,col=2,pch = 16, cex = 0.5)#
      polyd2 <- getpoly(quiet=TRUE)#
#
      fsc <- round(mean(c(polyd1[,1], polyd2[,1])))#
      d1 <- round(mean(polyd1[,2]))#
      d2 <- round(mean(polyd2[,2]))#
      inflection <- data.frame(fsc, d1, d2)#
#
  par(def.par)#
#
  return(inflection)#
}#
#
#' Get Notch and Offset values for Filter.notch function.#
#'#
#' @param inst Instrument serial number#
#' @param fsc Small forward scatter value of 1 µm beads#
#' @param d1 D1 value of 1 µm beads#
#' @param d2 D2 value of 1 µm beads#
#' @param slopes User-supplied filter slope CSV file, overriding the installed#
#'   default file.#
#' @return Data frame with filtering parameters for 2.5, 50.0, 97.5 quantiles#
#' @examples#
#' \dontrun{#
#' filt <- create.filter.params(inst, fsc, d1, d2)#
#' }#
#' @export#
create.filter.params <- function(inst, fsc, d1, d2, slope.file=NULL) {#
  # Rename to get correct dataframe headers#
  beads.fsc.small <- as.numeric(fsc)#
  beads.D1 <- as.numeric(d1)#
  beads.D2 <- as.numeric(d2)#
#
  width <- 2500#
#
  if (is.null(slope.file)) {#
    slope.file <- system.file("filter", "seaflow_filter_slopes.csv",package='popcycle')#
  }#
  slopes <- read.csv(slope.file)#
#
  filter.params <- data.frame()#
  headers <- c("quantile", "beads.fsc.small",#
               "beads.D1", "beads.D2", "width",#
               "notch.small.D1", "notch.small.D2",#
               "notch.large.D1", "notch.large.D2",#
               "offset.small.D1", "offset.small.D2",#
               "offset.large.D1", "offset.large.D2")#
#
  for (quantile in QUANTILES) {#
    if (quantile == 2.5) {#
      suffix <- "_2.5"#
    } else if (quantile == 97.5) {#
      suffix <- "_97.5"#
    } else if (quantile == 50.0) {#
      suffix <- ""#
    }#
#
    notch.small.D1 <- slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)]#
    notch.small.D2 <- slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)]#
    notch.large.D1 <- slopes[slopes$ins== inst, paste0('notch.large.D1', suffix)]#
    notch.large.D2 <- slopes[slopes$ins== inst, paste0('notch.large.D2', suffix)]#
    offset.small.D1 <- round(beads.D1 - notch.small.D1 * beads.fsc.small)#
    offset.small.D2 <- round(beads.D1 - notch.small.D2 * beads.fsc.small)#
    offset.large.D1 <- round(beads.D1 - notch.large.D1 * beads.fsc.small)#
    offset.large.D2 <- round(beads.D2 - notch.large.D2 * beads.fsc.small)#
#
    if(notch.small.D1 < 0 | notch.small.D2 < 0){#
      notch.small.D1 <- beads.D1/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)] / slopes[slopes$ins== inst, 'notch.small.D1']#
      notch.small.D2 <- beads.D2/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)] / slopes[slopes$ins== inst, 'notch.small.D2']#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      }#
#
    newrow <- data.frame(quantile, beads.fsc.small,#
                         beads.D1, beads.D2, width,#
                         notch.small.D1, notch.small.D2,#
                         notch.large.D1, notch.large.D2,#
                         offset.small.D1, offset.small.D2,#
                         offset.large.D1, offset.large.D2,#
                         stringsAsFactors=FALSE)#
    names(newrow) <- headers#
    filter.params <- rbind(filter.params, newrow)#
  }#
#
  return(filter.params)#
}#
#
#' Filter EVT particles with a generic filter function.#
#'#
#' @param evt EVT data frame.#
#' @param filter.func Filtering function.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.evt(evt, filter.notch, filter.params)#
#' }#
#' @export#
filter.evt <- function(evt, filter.func, ...) {#
  filt <- filter.func(evt, ...)#
#
  # SANITY CHECKS#
  # need same columns for opp#
  if (!all(names(evt) == names(filt$opp))) {#
    stop('Filtering function produced OPP with different columns')#
  }#
#
  return (filt)#
}#
#
#' Filter EVT particles.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.notch(evt, params)#
#' }#
#' @export#
filter.notch <- function(evt, filter.params) {#
  width <- as.numeric(filter.params$width)#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # Check for empty evt data frame.  If empty return empty opp data frame.#
  if (nrow(evt) == 0) {#
    return(list("opp"=data.frame(c())))#
  }#
#
  # linearize the LOG transformed data#
  lin <- FALSE#
  id <- which(colnames(evt) == "pulse_width" | colnames(evt) == "time" | colnames(evt) =="pop")#
  if (!any(max(evt[,-c(id)]) > 10^3.5)) {#
    evt <- untransformData(evt)#
    lin <- TRUE#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2)#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D + notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
      if(lin) opp <- transformData(opp)#
#
  params = list("width"=width,#
                "notch.small.D1"= notch.small.D1,"notch.small.D2"= notch.small.D2,#
                "notch.large.D1"= notch.large.D1,"notch.large.D2"= notch.large.D2,#
                "offset.small.D1"= offset.small.D1,"offset.small.D2"= offset.small.D2,#
                "offset.large.D1"= offset.large.D1,"offset.large.D2"= offset.large.D2)#
  return(list("opp"=opp, "params"=params))#
}#
#
#' Plot helpful cytograms for exploring filtering parameters.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram <- function(evt, filter.params) {#
  width <- 2500#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # linearize the LOG transformed data#
  id <- which(colnames(evt) == "fsc_small" | colnames(evt) == "chl_small" | colnames(evt) =="pe" | colnames(evt) =="fsc_perp" | colnames(evt) =="D1" | colnames(evt) =="D2")#
  if (!any(max(evt[,c(id)]) > 10^3.5)) {#
    evt[,c(id)] <- (log10(evt[,c(id)])/3.5)*2^16#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2), with Correction for the difference of sensitivity between D1 and D2#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D * notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
  opp <- subset(opp, fsc_small != 0)  #
  #################
  ### PLOTTING ####
  #################
  cols <- colorRampPalette(c("blue4","royalblue4","deepskyblue3", "seagreen3", "yellow", "orangered2","darkred"))#
  percent.opp <- round(100*nrow(opp)/nrow(evt.),2)#
  percent.noise <- round(100-100*nrow(evt.)/nrow(evt),0)#
#
  if(nrow(evt.) > 10000)  evt. <- evt.[round(seq(1,nrow(evt.), length.out=10000)),]#
  if(nrow(aligned) > 10000)  aligned <- aligned[round(seq(1,nrow(aligned), length.out=10000)),]#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
#
  par(mfrow=c(2,3),pty='s')#
#
  plot.cytogram(evt., "D1", "D2")#
  mtext("Alignment", side=3, line=3, font=2, col=2)#
  abline(b=1, a=width, col='red',lwd=2)#
  abline(b=1, a=- width, col='red',lwd=2)#
  plotrix:::draw.circle(0,0, radius=2000, border=2, lwd=2)#
  mtext(paste0("Noise = ", percent.noise, "%" ), side=3, line=2, font=2)#
  mtext(paste("Width=", width),side=3, line=1,font=2)#
#
  plot.cytogram(aligned, "fsc_small", "D1")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D1, a=offset.small.D1,col=2)#
  abline(b=notch.large.D1, a=offset.large.D1,col=3)#
#
  plot.cytogram(aligned, "fsc_small", "D2")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D2, a=offset.small.D2,col=2)#
  abline(b=notch.large.D2, a=offset.large.D2,col=3)#
#
  plot.cytogram(opp, "fsc_small", "pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "fsc_small","chl_small")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "chl_small","pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  mtext(paste("OPP =", percent.opp,"% EVT"), outer=T,side=1, line=-2,font=2,col=1)#
#
  par(def.par)#
}#
#
#' Plot helpful cytograms for exploring filtering parameters for one file.#
#'#
#' @param evt.dir EVT file directory.#
#' @param file.name File name with julian day directory.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram.by.file <- function(evt.dir, file.name, filter.params) {#
  file.name <- clean.file.path(file.name)#
  evt <- readSeaflow(file.path(evt.dir, file.name))#
  plot.filter.cytogram(evt, filter.params)#
}#
#' Filter a list of EVT files.#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param evt.dir EVT file directory.#
#' @param evt.files List of EVT files to filter. Include julian day directory.#
#' @param opp.dir OPP file output directory.#
#' @param filter.id Optionally provide the ID for filter parameters. If NULL,#
#'   the most recently saved filter parameters will be used.#
#' @return None#
#' @examples#
#' \dontrun{#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir)#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir,#
#'                  "d3afb1ea-ad20-46cf-866d-869300fe17f4")#
#' }#
#' @export#
filter.evt.files <- function(db, evt.dir, evt.files, opp.dir,#
                             filter.id=NULL) {#
  # Get notch and width to use from params file#
  # Return empty data frame on warning or error#
  if (is.null(filter.id)) {#
    filter.params <- get.filter.params.latest(db)#
  } else {#
    filter.params <- get.filter.params.by.id(db, filter.id)#
  }#
#
  if (nrow(filter.params) == 0) {#
    stop("No filter parameters defined")#
  }#
#
  i <- 0#
  for (evt.file in evt.files) {#
    message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
#
    # Read EVT file#
    # Create empty data frame on warning or error#
    evt <- tryCatch({#
      path <- file.path(evt.dir, evt.file)#
      readSeaflow(path, transform=FALSE)#
    }, warnings = function(err) {#
      print(err)#
      return(data.frame())#
    }, error = function(err) {#
      print(err)#
      return(data.frame())#
    })#
    evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
    evt_count <- nrow(evt.)#
    all_count <- nrow(evt)#
#
    # Delete all versions of this OPP file#
    delete.opp.by.file(opp.dir, evt.file)#
#
    for (quantile in QUANTILES) {#
      p <- filter.params[filter.params$quantile == quantile, ]#
      # Filter EVT to OPP#
      # Return empty data frame on warning or error#
      result <- tryCatch({#
        filter.evt(evt, filter.notch, p)#
      }, warnings = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      }, error = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      })#
#
      # Save OPP data#
      if (nrow(result$opp) > 0) {#
        save.opp.stats(db, evt.file, all_count, evt_count,#
                       result$opp, p$id, quantile)#
        save.opp.file(result$opp, opp.dir, evt.file, quantile)#
      }#
    }#
#
    i <-  i + 1#
    flush.console()#
  }#
  message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
  flush.console()#
}#
#
#' Filter a directory of EVT files using seaflowpy_filter#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param cruise.name Cruise name.#
#' @param evt.dir EVT file directory.#
#' @param opp.dir OPP file output directory.#
#' @param process.count Number of processes to start for filtering.#
#' @param limit Only process up to this many files.#
#' @param resolution Progress update resolution in \%.#
#' @param width,notch.small.D1, notch.small.D2, notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2, offset.large.D1, offset.large.D2 Filter parameters.#
#' @return None#
#' @examples#
#' \dontrun{#
#' seaflowpy_filter("testcruise.db", "testcruise", "./testcruise", "./testcruise_opp")#
#' }#
#' @export#
seaflowpy_filter <- function(db, cruise.name, evt.dir, opp.dir, process.count=1, twopass=FALSE,#
                             limit=NULL, resolution=NULL, width=NULL,#
                             notch.small.D1=NULL, notch.small.D2=NULL,#
                             notch.large.D1=NULL, notch.large.D2=NULL,#
                             offset.small.D1=NULL, offset.small.D2=NULL,#
                             offset.large.D1=NULL, offset.large.D2=NULL){#
#
  # First check for seaflowpy_filter in PATH#
  result <- tryCatch(#
    {#
      system2("bash", c("-lc", "'seaflowpy_filter --version'"), stdout=TRUE, stderr=TRUE)#
    },#
    warning=function(w) {#
      invisible(w)#
    },#
    error=function(e) {#
      return("system2error")#
    }#
  )#
  if (result == "system2error") {#
    warning("Could not run seaflowpy_filter")#
    return()#
  }#
#
  cmd <- paste0("'seaflowpy_filter ", '-c "', cruise.name, '" -e "',#
                normalizePath(evt.dir), '" -o "',  normalizePath(opp.dir),#
                '" -d "', normalizePath(db), '"')#
  if (! is.null(process.count)) {#
    cmd <- paste0(cmd, " -p ", process.count)#
  }#
  if (! is.null(resolution)) {#
    cmd <- paste0(cmd, " -r ", resolution)#
  }#
  if (! is.null(limit)) {#
    cmd <- paste0(cmd, " -l ", limit)#
  }#
  if (! is.null(width)) {#
    cmd <- paste0(cmd, " --width ", width)#
  }#
  if (! is.null(notch.small.D1)) {#
    cmd <- paste0(cmd, " --notch.small.D1 ", notch.small.D1)#
  }#
  if (! is.null(notch.small.D2)) {#
    cmd <- paste0(cmd, " --notch.small.D2 ", notch.small.D2)#
  }#
  if (! is.null(notch.largel.D1)) {#
    cmd <- paste0(cmd, " --notch.large.D1 ", notch.large.D1)#
  }#
  if (! is.null(notch.large.D2)) {#
    cmd <- paste0(cmd, " --notch.large.D2 ", notch.large.D2)#
  }#
  if (! is.null(offset.small.D1)) {#
    cmd <- paste0(cmd, " --offset.small.D1 ", offset.small.D1)#
  }#
  if (! is.null(offset.small.D2)) {#
    cmd <- paste0(cmd, " --offset.small.D2 ", offset.small.D2)#
  }#
  if (! is.null(offset.largel.D1)) {#
    cmd <- paste0(cmd, " --offset.large.D1 ", offset.large.D1)#
  }#
  if (! is.null(offset.large.D2)) {#
    cmd <- paste0(cmd, " --offset.large.D2 ", offset.large.D2)#
  }#
  cmd <- paste0(cmd, "'")#
  system2("bash", c("-lc", cmd))#
}
plot.filter.cytogram(evt, params)
#' Plot helpful cytograms for estimating the D1, D2 and FSC coordinates of the inflection point (corresponds to location of 1µm beads).#
#'#
#' @param dataframe containing EVT data.#
#' @return D1, D2 and fsc values of presumed 1 µm beads#
#' @export#
inflection.point <- function(DF){#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
  par(mfrow=c(1,3),pty='s')#
#
  plot.cytogram(DF, "fsc_small", "pe")#
    poly.beads <- getpoly(quiet=TRUE)#
    b <- subset(DF,inout(DF[,c("fsc_small", "pe")],poly=poly.beads, bound=TRUE, quiet=TRUE))#
#
  plot.cytogram(DF, "fsc_small", "D1");points(b$fsc_small, b$D1,col=2, pch = 16, cex = 0.5)#
      polyd1 <- getpoly(quiet=TRUE)#
#
  plot.cytogram(DF, "fsc_small", "D2");points(b$fsc_small, b$D2,col=2,pch = 16, cex = 0.5)#
      polyd2 <- getpoly(quiet=TRUE)#
#
      fsc <- round(mean(c(polyd1[,1], polyd2[,1])))#
      d1 <- round(mean(polyd1[,2]))#
      d2 <- round(mean(polyd2[,2]))#
      inflection <- data.frame(fsc, d1, d2)#
#
  par(def.par)#
#
  return(inflection)#
}#
#
#' Get Notch and Offset values for Filter.notch function.#
#'#
#' @param inst Instrument serial number#
#' @param fsc Small forward scatter value of 1 µm beads#
#' @param d1 D1 value of 1 µm beads#
#' @param d2 D2 value of 1 µm beads#
#' @param slopes User-supplied filter slope CSV file, overriding the installed#
#'   default file.#
#' @return Data frame with filtering parameters for 2.5, 50.0, 97.5 quantiles#
#' @examples#
#' \dontrun{#
#' filt <- create.filter.params(inst, fsc, d1, d2)#
#' }#
#' @export#
create.filter.params <- function(inst, fsc, d1, d2, slope.file=NULL) {#
  # Rename to get correct dataframe headers#
  beads.fsc.small <- as.numeric(fsc)#
  beads.D1 <- as.numeric(d1)#
  beads.D2 <- as.numeric(d2)#
#
  width <- 2500#
#
  if (is.null(slope.file)) {#
    slope.file <- system.file("filter", "seaflow_filter_slopes.csv",package='popcycle')#
  }#
  slopes <- read.csv(slope.file)#
#
  filter.params <- data.frame()#
  headers <- c("quantile", "beads.fsc.small",#
               "beads.D1", "beads.D2", "width",#
               "notch.small.D1", "notch.small.D2",#
               "notch.large.D1", "notch.large.D2",#
               "offset.small.D1", "offset.small.D2",#
               "offset.large.D1", "offset.large.D2")#
#
  for (quantile in QUANTILES) {#
    if (quantile == 2.5) {#
      suffix <- "_2.5"#
    } else if (quantile == 97.5) {#
      suffix <- "_97.5"#
    } else if (quantile == 50.0) {#
      suffix <- ""#
    }#
#
    notch.small.D1 <- slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)]#
    notch.small.D2 <- slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)]#
    notch.large.D1 <- slopes[slopes$ins== inst, paste0('notch.large.D1', suffix)]#
    notch.large.D2 <- slopes[slopes$ins== inst, paste0('notch.large.D2', suffix)]#
    offset.small.D1 <- round(beads.D1 - notch.small.D1 * beads.fsc.small)#
    offset.small.D2 <- round(beads.D1 - notch.small.D2 * beads.fsc.small)#
    offset.large.D1 <- round(beads.D1 - notch.large.D1 * beads.fsc.small)#
    offset.large.D2 <- round(beads.D2 - notch.large.D2 * beads.fsc.small)#
#
    #if(notch.small.D1 < 0 | notch.small.D2 < 0){#
      notch.small.D1 <- beads.D1/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D1', suffix)] / slopes[slopes$ins== inst, 'notch.small.D1']#
      notch.small.D2 <- beads.D2/beads.fsc.small  * slopes[slopes$ins== inst, paste0('notch.small.D2', suffix)] / slopes[slopes$ins== inst, 'notch.small.D2']#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
  #    }#
#
    newrow <- data.frame(quantile, beads.fsc.small,#
                         beads.D1, beads.D2, width,#
                         notch.small.D1, notch.small.D2,#
                         notch.large.D1, notch.large.D2,#
                         offset.small.D1, offset.small.D2,#
                         offset.large.D1, offset.large.D2,#
                         stringsAsFactors=FALSE)#
    names(newrow) <- headers#
    filter.params <- rbind(filter.params, newrow)#
  }#
#
  return(filter.params)#
}#
#
#' Filter EVT particles with a generic filter function.#
#'#
#' @param evt EVT data frame.#
#' @param filter.func Filtering function.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.evt(evt, filter.notch, filter.params)#
#' }#
#' @export#
filter.evt <- function(evt, filter.func, ...) {#
  filt <- filter.func(evt, ...)#
#
  # SANITY CHECKS#
  # need same columns for opp#
  if (!all(names(evt) == names(filt$opp))) {#
    stop('Filtering function produced OPP with different columns')#
  }#
#
  return (filt)#
}#
#
#' Filter EVT particles.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return Named list where list$params contains a list of filtering parameters#
#'   and list$opp contains OPP data frame.#
#' @examples#
#' \dontrun{#
#' filt <- filter.notch(evt, params)#
#' }#
#' @export#
filter.notch <- function(evt, filter.params) {#
  width <- as.numeric(filter.params$width)#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # Check for empty evt data frame.  If empty return empty opp data frame.#
  if (nrow(evt) == 0) {#
    return(list("opp"=data.frame(c())))#
  }#
#
  # linearize the LOG transformed data#
  lin <- FALSE#
  id <- which(colnames(evt) == "pulse_width" | colnames(evt) == "time" | colnames(evt) =="pop")#
  if (!any(max(evt[,-c(id)]) > 10^3.5)) {#
    evt <- untransformData(evt)#
    lin <- TRUE#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2)#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D + notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
      if(lin) opp <- transformData(opp)#
#
  params = list("width"=width,#
                "notch.small.D1"= notch.small.D1,"notch.small.D2"= notch.small.D2,#
                "notch.large.D1"= notch.large.D1,"notch.large.D2"= notch.large.D2,#
                "offset.small.D1"= offset.small.D1,"offset.small.D2"= offset.small.D2,#
                "offset.large.D1"= offset.large.D1,"offset.large.D2"= offset.large.D2)#
  return(list("opp"=opp, "params"=params))#
}#
#
#' Plot helpful cytograms for exploring filtering parameters.#
#'#
#' @param evt EVT data frame.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram <- function(evt, filter.params) {#
  width <- 2500#
  notch.small.D1 <- as.numeric(filter.params$notch.small.D1)#
  notch.small.D2 <- as.numeric(filter.params$notch.small.D2)#
  notch.large.D1 <- as.numeric(filter.params$notch.large.D1)#
  notch.large.D2 <- as.numeric(filter.params$notch.large.D2)#
  offset.small.D1 <- as.numeric(filter.params$offset.small.D1)#
  offset.small.D2 <- as.numeric(filter.params$offset.small.D2)#
  offset.large.D1 <- as.numeric(filter.params$offset.large.D1)#
  offset.large.D2 <- as.numeric(filter.params$offset.large.D2)#
#
  # linearize the LOG transformed data#
  id <- which(colnames(evt) == "fsc_small" | colnames(evt) == "chl_small" | colnames(evt) =="pe" | colnames(evt) =="fsc_perp" | colnames(evt) =="D1" | colnames(evt) =="D2")#
  if (!any(max(evt[,c(id)]) > 10^3.5)) {#
    evt[,c(id)] <- (log10(evt[,c(id)])/3.5)*2^16#
  }#
#
  # Filtering out noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2), with Correction for the difference of sensitivity between D1 and D2#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
  # Filtering focused particles (fsc_small > D * notch)#
  opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
      D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
  opp <- subset(opp, fsc_small != 0)  #
  #################
  ### PLOTTING ####
  #################
  cols <- colorRampPalette(c("blue4","royalblue4","deepskyblue3", "seagreen3", "yellow", "orangered2","darkred"))#
  percent.opp <- round(100*nrow(opp)/nrow(evt.),2)#
  percent.noise <- round(100-100*nrow(evt.)/nrow(evt),0)#
#
  if(nrow(evt.) > 10000)  evt. <- evt.[round(seq(1,nrow(evt.), length.out=10000)),]#
  if(nrow(aligned) > 10000)  aligned <- aligned[round(seq(1,nrow(aligned), length.out=10000)),]#
#
  def.par <- par(no.readonly = TRUE) # save default, for resetting...#
#
  par(mfrow=c(2,3),pty='s')#
#
  plot.cytogram(evt., "D1", "D2")#
  mtext("Alignment", side=3, line=3, font=2, col=2)#
  abline(b=1, a=width, col='red',lwd=2)#
  abline(b=1, a=- width, col='red',lwd=2)#
  plotrix:::draw.circle(0,0, radius=2000, border=2, lwd=2)#
  mtext(paste0("Noise = ", percent.noise, "%" ), side=3, line=2, font=2)#
  mtext(paste("Width=", width),side=3, line=1,font=2)#
#
  plot.cytogram(aligned, "fsc_small", "D1")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D1, a=offset.small.D1,col=2)#
  abline(b=notch.large.D1, a=offset.large.D1,col=3)#
#
  plot.cytogram(aligned, "fsc_small", "D2")#
  mtext("Focus", side=3, line=3, font=2,col=2)#
  abline(b=notch.small.D2, a=offset.small.D2,col=2)#
  abline(b=notch.large.D2, a=offset.large.D2,col=3)#
#
  plot.cytogram(opp, "fsc_small", "pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "fsc_small","chl_small")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  plot.cytogram(opp, "chl_small","pe")#
  mtext("OPP", side=3, line=1, font=2, col=2)#
  mtext(paste("OPP =", percent.opp,"% EVT"), outer=T,side=1, line=-2,font=2,col=1)#
#
  par(def.par)#
}#
#
#' Plot helpful cytograms for exploring filtering parameters for one file.#
#'#
#' @param evt.dir EVT file directory.#
#' @param file.name File name with julian day directory.#
#' @param filter.params Filtering parameters in a one row data frame or named#
#'   list. Columns should include width, notch.small.D1, notch.small.D2,#
#'   notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2,#
#'   offset.large.D1, offset.large.D2.#
#' @return None#
#' @export#
plot.filter.cytogram.by.file <- function(evt.dir, file.name, filter.params) {#
  file.name <- clean.file.path(file.name)#
  evt <- readSeaflow(file.path(evt.dir, file.name))#
  plot.filter.cytogram(evt, filter.params)#
}#
#' Filter a list of EVT files.#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param evt.dir EVT file directory.#
#' @param evt.files List of EVT files to filter. Include julian day directory.#
#' @param opp.dir OPP file output directory.#
#' @param filter.id Optionally provide the ID for filter parameters. If NULL,#
#'   the most recently saved filter parameters will be used.#
#' @return None#
#' @examples#
#' \dontrun{#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir)#
#' filter.evt.files(db, evt.dir, evt.files, opp.dir,#
#'                  "d3afb1ea-ad20-46cf-866d-869300fe17f4")#
#' }#
#' @export#
filter.evt.files <- function(db, evt.dir, evt.files, opp.dir,#
                             filter.id=NULL) {#
  # Get notch and width to use from params file#
  # Return empty data frame on warning or error#
  if (is.null(filter.id)) {#
    filter.params <- get.filter.params.latest(db)#
  } else {#
    filter.params <- get.filter.params.by.id(db, filter.id)#
  }#
#
  if (nrow(filter.params) == 0) {#
    stop("No filter parameters defined")#
  }#
#
  i <- 0#
  for (evt.file in evt.files) {#
    message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
#
    # Read EVT file#
    # Create empty data frame on warning or error#
    evt <- tryCatch({#
      path <- file.path(evt.dir, evt.file)#
      readSeaflow(path, transform=FALSE)#
    }, warnings = function(err) {#
      print(err)#
      return(data.frame())#
    }, error = function(err) {#
      print(err)#
      return(data.frame())#
    })#
    evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
    evt_count <- nrow(evt.)#
    all_count <- nrow(evt)#
#
    # Delete all versions of this OPP file#
    delete.opp.by.file(opp.dir, evt.file)#
#
    for (quantile in QUANTILES) {#
      p <- filter.params[filter.params$quantile == quantile, ]#
      # Filter EVT to OPP#
      # Return empty data frame on warning or error#
      result <- tryCatch({#
        filter.evt(evt, filter.notch, p)#
      }, warnings = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      }, error = function(err) {#
        print(err)#
        return(list(opp=data.frame()))#
      })#
#
      # Save OPP data#
      if (nrow(result$opp) > 0) {#
        save.opp.stats(db, evt.file, all_count, evt_count,#
                       result$opp, p$id, quantile)#
        save.opp.file(result$opp, opp.dir, evt.file, quantile)#
      }#
    }#
#
    i <-  i + 1#
    flush.console()#
  }#
  message(round(100*i/length(evt.files)), "% completed \r", appendLF=FALSE)#
  flush.console()#
}#
#
#' Filter a directory of EVT files using seaflowpy_filter#
#'#
#' Filter a list of EVT files. Save OPP per file aggregate statistics to#
#' SQLite3 database and save particle data to binary files in opp.dir.#
#'#
#' @param db SQLite3 database file path.#
#' @param cruise.name Cruise name.#
#' @param evt.dir EVT file directory.#
#' @param opp.dir OPP file output directory.#
#' @param process.count Number of processes to start for filtering.#
#' @param limit Only process up to this many files.#
#' @param resolution Progress update resolution in \%.#
#' @param width,notch.small.D1, notch.small.D2, notch.large.D1, notch.large.D2, offset.small.D1, offset.small.D2, offset.large.D1, offset.large.D2 Filter parameters.#
#' @return None#
#' @examples#
#' \dontrun{#
#' seaflowpy_filter("testcruise.db", "testcruise", "./testcruise", "./testcruise_opp")#
#' }#
#' @export#
seaflowpy_filter <- function(db, cruise.name, evt.dir, opp.dir, process.count=1, twopass=FALSE,#
                             limit=NULL, resolution=NULL, width=NULL,#
                             notch.small.D1=NULL, notch.small.D2=NULL,#
                             notch.large.D1=NULL, notch.large.D2=NULL,#
                             offset.small.D1=NULL, offset.small.D2=NULL,#
                             offset.large.D1=NULL, offset.large.D2=NULL){#
#
  # First check for seaflowpy_filter in PATH#
  result <- tryCatch(#
    {#
      system2("bash", c("-lc", "'seaflowpy_filter --version'"), stdout=TRUE, stderr=TRUE)#
    },#
    warning=function(w) {#
      invisible(w)#
    },#
    error=function(e) {#
      return("system2error")#
    }#
  )#
  if (result == "system2error") {#
    warning("Could not run seaflowpy_filter")#
    return()#
  }#
#
  cmd <- paste0("'seaflowpy_filter ", '-c "', cruise.name, '" -e "',#
                normalizePath(evt.dir), '" -o "',  normalizePath(opp.dir),#
                '" -d "', normalizePath(db), '"')#
  if (! is.null(process.count)) {#
    cmd <- paste0(cmd, " -p ", process.count)#
  }#
  if (! is.null(resolution)) {#
    cmd <- paste0(cmd, " -r ", resolution)#
  }#
  if (! is.null(limit)) {#
    cmd <- paste0(cmd, " -l ", limit)#
  }#
  if (! is.null(width)) {#
    cmd <- paste0(cmd, " --width ", width)#
  }#
  if (! is.null(notch.small.D1)) {#
    cmd <- paste0(cmd, " --notch.small.D1 ", notch.small.D1)#
  }#
  if (! is.null(notch.small.D2)) {#
    cmd <- paste0(cmd, " --notch.small.D2 ", notch.small.D2)#
  }#
  if (! is.null(notch.largel.D1)) {#
    cmd <- paste0(cmd, " --notch.large.D1 ", notch.large.D1)#
  }#
  if (! is.null(notch.large.D2)) {#
    cmd <- paste0(cmd, " --notch.large.D2 ", notch.large.D2)#
  }#
  if (! is.null(offset.small.D1)) {#
    cmd <- paste0(cmd, " --offset.small.D1 ", offset.small.D1)#
  }#
  if (! is.null(offset.small.D2)) {#
    cmd <- paste0(cmd, " --offset.small.D2 ", offset.small.D2)#
  }#
  if (! is.null(offset.largel.D1)) {#
    cmd <- paste0(cmd, " --offset.large.D1 ", offset.large.D1)#
  }#
  if (! is.null(offset.large.D2)) {#
    cmd <- paste0(cmd, " --offset.large.D2 ", offset.large.D2)#
  }#
  cmd <- paste0(cmd, "'")#
  system2("bash", c("-lc", cmd))#
}
library(scales)#
library(plotrix)#
library(maps)#
library(DEoptim)#
#
dir <- "/Volumes/GoogleDrive/My Drive/manuscript_2/data"#
setwd(dir)#
#
GR <- read.csv("nutrient-GRproV3.csv")#
GR$clim.DIN.darwin <- GR$clim.nh4.darwin + GR$clim.no2.darwin + GR$clim.no3.darwin#
#
cols <- colorRampPalette(c("blue4", "deepskyblue3",  "seagreen3", "yellow", "orangered2", "darkred"))#
##########################
#### CREATE FUNCTIONs ####
##########################
#
nut.temp.gr.matrix <- function(y, ksat, mumax, tau1, A){#
#
    temp <- seq(10,30,length.out=200)#
    nut <- seq(min(y, na.rm=T), max(y, na.rm=T),length.out=200)#
#
    ## NUT (Michaelis-Menten)#
    #ksat <- 3.8       #3.8 nM PO4 +/- 3.8 Lomas et al. 2013 (Prochlorocccus at 5 m)#
    #mumax <- 9*10^-6*(60*60*24) # mumax try to match Seaflow data#
#
    ## TEMP (Pseudo-eppley)#
    #tau1 <- 0.07 # 0.15 # 0.50; 0.33#
    #A <- 0.11 #0.063 #  1.05#
    tlimitt <- tau1*exp(A*temp)#
#
    ## calculate GR given tlimitt for each nut values#
    muept <- matrix(NA, ncol= length(nut), nrow=length(tlimitt))#
    colnames(muept) <- nut#
    row.names(muept) <- temp#
#
    for(inut in 1:length(nut)) muept[,inut] <- mumax*tlimitt*nut[inut]/(nut[inut]+ksat)#
#
      return(muept)#
  }#
#
find.values.matrix <- function(x, y, t){#
#
    if(length(x) != length(y)) {#
      print("length of x is not equal length of y")#
      stop#
    }#
      temp <- as.numeric(rownames(t))#
      nut <- as.numeric(colnames(t))#
      id.x <- findInterval(x, temp, all.inside=T)#
      id.y <- findInterval(y, nut, all.inside=T)#
#
      DF <- NULL#
      for(id in 1:length(x)){#
        df <- t[id.x[id],id.y[id]]#
        DF <- c(DF,df)#
        }#
        return(DF)#
    }#
#
nut.temp.gr <- function(x, y, ksat, mumax, tau1, A){#
#
  DF <- mumax * (y/(y+ksat) * tau1 * exp(A * x))#
  return(DF)#
#
}#
#
sigma.lsq <- function(x, y, z, params){#
#
    # ksat <- 3.8#
    # mumax <- 0.8#
    # tau1 <- 0.07#
    # A <- 0.11#
    # params <- res$optim$bestmem#
    ##
      ksat <- params[1]#
      mumax <- params[2]#
      tau1 <- params[3]#
      A <- params[4]#
      # t <-  nut.temp.gr.matrix(y, ksat, mumax, tau1, A)#
      # id <- find.values.matrix(x=x, y=y, t)#
      id <- nut.temp.gr(x, y, ksat, mumax, tau1, A)#
      df <- data.frame(obs=z, pred=id)#
      sigma <- mean(abs(df$obs - df$pred)/df$obs,na.rm=T)#
      return(sigma*100)#
  }#
plot.validation <- function(x, y, z, t, id,...){#
    cols <- colorRampPalette(c("blue4", "royalblue4", "deepskyblue3",  "seagreen3", "yellow", "orangered2", "darkred"))#
#
    df <- data.frame(obs=z, pred=id)#
    temp <- as.numeric(rownames(t))#
    nut <- as.numeric(colnames(t))#
#
    l <- lm(pred ~ obs, data=df)#
#
    par(mfrow=c(1,2),pty='s',cex=1.2)#
      image(x=temp,y=nut, z=t, col=cols(100),xlab="Temp (˚C)", ylab="Nutrients (nM)", ...)#
        points(x, y, pch=21, col='white', cex=1.5)#, bg=cols(100)[cut(z,100)])#
#
        mtext(expression("GR" == paste("µ"["max"], frac("R", "R + k"["sat"]),#
                " ",gamma, e^{"AT"})), cex = 1.2, 3,4)#
#
      plot(df$obs, df$pred, xlab=expression(paste("Obs GR (d"^{-1},")")), ylab=expression(paste("Pred GR (d"^{-1},")")), xlim=c(0,1), ylim=c(0,1))#
        abline(b=1,a=0, lty=2)#
        abline(b=l$coefficients[2],a=l$coefficients[1], lty=1,col=2,lwd=2)#
    }#
#################
### FIGURE 1 ####
#################
png("Figure1.png",width=14, height=10, unit='in', res=500)#
#
para <- 'season'#
cex <- 1.4#
def.par <- par(no.readonly = TRUE) # save default, for resetting...#
layout(matrix(c(2,1,1,3,1,1), 2, 3, byrow = TRUE))#
par(cex=cex, pty='s')#
#
plotCI(GR$temperature, GR$dr, GR$dr.sd, pch=NA, col='grey', sfrac=0, lwd=2, xlab="Temp (˚C)",ylab=expression(paste("GR (d"^{-1},")")),ylim=c(0,1), las=1)#
plotCI(GR$temperature, GR$dr, GR$temperature.sd, err='x', pch=NA, col='grey', sfrac=0, lwd=2, add=T)#
legend("topleft",legend=unique(GR$season), pch=21, col='lightgrey',pt.bg=alpha(cols(length(unique(GR[,para])))), bty='n',cex=cex/1.5)#
  i <- 1#
  for(cruise in unique(GR[,para])){#
      GR2 <- subset(GR, GR[,para] == cruise)#
      points(GR2$temperature, GR2$dr, pch=21, col='lightgrey',bg=alpha(cols(length(unique(GR[,para])))[i],0.5), cex=cex)#
      i <- 1 + i#
      }#
#
    choice <- c("average", "max")#
    d <- choice[2]#
    dtemp <- 1.5#
    temp.range <- round(range(GR$temperature, na.rm=T))#
    seq.temp <- seq(temp.range[1], temp.range[2]+1, by=dtemp)#
    cut.temp <- cut(GR$temperature, seq.temp)#
    temp <- tapply(GR$temperature, cut.temp, function(x) mean(x, na.rm=T))#
    if (d == "max") gr <- tapply(GR$dr, cut.temp, function(x) max(x, na.rm=T))#
    if(d == "average") gr <- tapply(GR$dr, cut.temp, function(x) mean(x, na.rm=T))#
    if(d == "average") df <- data.frame(temp, gr)#
    if (d == "max") df <- data.frame(temp, gr); df <- subset(df, temp < 27)#
    # points(data$temp, data$gr)#
    if(d == "average") fit <- lm(gr ~ poly(temp,1,raw=T), df)#
    if(d == "max") fit <- lm(gr ~ poly(temp,2,raw=T), df)#
#
    summary(fit)#
    pred <- predict.lm(fit, newdata=data.frame(temperature=temp), interval='confidence')#
lines(temp, pred[,'fit'], lwd=2, col='red3')#
lines(temp, pred[,'lwr'], lwd=1, col=1,lty=2)#
lines(temp, pred[,'upr'], lwd=1, col=1,lty=2)#
mtext("B", at=par("usr")[4], side=2, line=3,cex=cex*2, las=1)#
#
# ########
# Q10 <- NULL#
# for(i in 1:(nrow(pred)-1)){#
#   q10.mean <- (pred[i+1,'fit']/pred[i,'fit'])^(10/dtemp)#
#   q10.lwr <- (pred[i+1,'lwr']/pred[i,'lwr'])^(10/dtemp)#
#   q10.upr <- (pred[i+1,'upr']/pred[i,'upr'])^(10/dtemp)#
#   q10 <- cbind(q10.mean, q10.lwr, q10.upr)#
#   Q10 <- data.frame(rbind(Q10, q10))#
# }#
# q <- round(mean(Q10[,1], na.rm=T),1)#
# q.lwr <- round(mean(Q10[,2], na.rm=T),1)#
# q.upr <- round(mean(Q10[,3], na.rm=T),1)#
# print(paste0("Q10 = ", q, " (",q.upr," - ",q.lwr,")"))#
plot(c(min(GR$lon,na.rm=T)-5,max(GR$lon,na.rm=T)+5) , range(GR$lat,na.rm=T), pch=NA, asp=1, las=1, xlab="Lon (˚W)", ylab="Lat (˚N)")#
  i <- 1#
  for(cruise in unique(GR[,para])){#
      GR2 <- subset(GR, GR[,para] == cruise)#
      GR2 <- GR2[order(GR2$lat),]#
      points(GR2$lon, GR2$lat, pch=21, col='grey', bg=alpha(cols(length(unique(GR[,para])))[i],0.5), cex=cex)#
      i <- 1 + i#
  }#
  map("world", fill = T, col = "black", add = TRUE)#
  mtext("A", at=par("usr")[4], side=2, line=3,cex=cex*2, las=1)#
  nut <- "PO4"#
  plotCI(GR$temperature,GR[,nut],GR$temperature.sd, err='x', pch=NA, col='grey', sfrac=0, lwd=2, ylab=paste(nut, "(nM)"), xlab="Temp (˚C)",las=1)#
  i <- 1#
  for(cruise in unique(GR[,para])){#
      GR2 <- subset(GR, GR[,para] == cruise)#
      points(GR2$temperature,GR2[,nut],  pch=21, col='lightgrey',bg=alpha(cols(length(unique(GR[,para])))[i],0.5), cex=cex)#
      i <- 1 + i#
  }#
  fit <- lm(GR[,nut] ~ poly(temperature,1,raw=T), GR)#
  summary(fit)#
  pred <- predict.lm(fit, newdata=data.frame(temperature=temp), interval='confidence')#
  lines(temp, pred[,'fit'], lwd=2, col='red3')#
  mtext("C", at=par("usr")[4], side=2, line=3,cex=cex*2, las=1)#
#
par(def.par)#
#
dev.off()
#####################################
### 1. SET FILTRATION PARAMETERS ####
#####################################
df <- c("MBARI1",47814,24114,22436,#
"SCOPE6",49664,16840,17669,#
"DeepDOM",48977,19167,19617,#
"Gradient1",51625,34693,33630)#
beads.coord <- data.frame(matrix(df, 4,4, byrow=T),stringsAsFactors=F)#
colnames(beads.coord) <- c("cruise","fsc","d1","d2")#
#Path to the Git repository#
setwd("~/Documents/DATA/Codes/seaflow-virtualcore/2.cruise_calibration/")#
gate <- FALSE#
allcruises <- c("SCOPE6", "DeepDOM", "MBARI1","Gradient1")#
#
for(cruise in allcruises){#
#
  #cruise <- allcruises[1]#
#
  print(cruise)#
  ### Get EVT list#
  if(cruise == "SCOPE6" | cruise == "Gradient1") list <- list.files(paste0(path.to.data,cruise,"data"), "00-00$",full.names=T, recursive=T)#
  if(cruise == "DeepDOM"| cruise == "MBARI1") list <- list.files(paste0(path.to.data,cruise,"data"), ".evt$",full.names=T, recursive=T)#
#
  if(cruise == "SCOPE6") inst <- 740#
  if(cruise == "DeepDOM" | cruise == "MBARI1") inst <- 989#
  if(cruise == "Gradient1") inst <- 751#
#
  # SLOPES#
  slopes <- read.csv("seaflow_filter_slopes.csv")#
#
  # BEADS#
  beads.fsc <- as.numeric(beads.coord[which(beads.coord$cruise == cruise),"fsc"])#
  beads.d1 <- as.numeric(beads.coord[which(beads.coord$cruise == cruise),"d1"])#
  beads.d2 <- as.numeric(beads.coord[which(beads.coord$cruise == cruise),"d2"])#
#
width <- 2500#
ALL <- NULL#
#
for (file in list){#
#
  #file <- list[4]#
  print(file)#
#
  evt <- readSeaflow(file,transform=F)#
#
  # Filtering noise#
  evt. <- evt[evt$fsc_small > 1 | evt$D1 > 1 | evt$D2 > 1, ]#
#
  # Fltering aligned particles (D1 = D2), with Correction for the difference of sensitivity between D1 and D2#
  aligned <- subset(evt., D2 < D1 + width & D1 < D2 + width)#
#
    if(nrow(aligned)> 100000){aligned. <- sample_n(aligned, 100000)#
      } else aligned. <- aligned#
#
    if(nrow(evt.)> 100000){df <- sample_n(evt., 100000)#
      } else df <- evt.#
    # par(mfrow=c(2,2))#
    # plot.cytogram(df, "D1", "D2"); abline(b=notch, a=origin)#
    # plot.cytogram(aligned., "D1", "D2"); abline(b=1, a=origin)#
    # plot.cytogram(df, "fsc_small", "D1"); abline(b=notch.small.D1, a=offset.small.D1,col=2); abline(b=notch.large.D1, a=offset.large.D1,col=3); points(beads.fsc, beads.d1,pch=16, col=3)#
    # plot.cytogram(df, "fsc_small", "D2"); abline(b=notch.small.D2, a=offset.small.D2,col=2); abline(b=notch.large.D2, a=offset.large.D2,col=3); points(beads.fsc, beads.d2,pch=16, col=3)#
#
    screening <- c(-12500,-10000,-7500,-5000,-2500,0,2500,5000,7500,10000,12500, 1, 2, 3)#
#
  for(corr in screening){#
#
  print(paste("corr=", corr))#
  notch.small.D1 <- slopes[slopes$ins== inst,'notch.small.D1']#
  notch.small.D2 <- slopes[slopes$ins== inst,'notch.small.D2']#
  notch.large.D1 <- slopes[slopes$ins== inst,'notch.large.D1']#
  notch.large.D2 <- slopes[slopes$ins== inst,'notch.large.D2']#
  offset.small.D1 <- round(beads.d1 - notch.small.D1 * beads.fsc) + corr#
  offset.small.D2 <- round(beads.d2 - notch.small.D2 * beads.fsc) + corr#
  offset.large.D1 <- round(beads.d1 - notch.large.D1 * beads.fsc) + corr#
  offset.large.D2 <- round(beads.d2 - notch.large.D2 * beads.fsc) + corr#
    if(corr == 1){#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      notch.small.D1 <- slopes[slopes$ins== inst,'notch.small.D1']#
      notch.small.D2 <- slopes[slopes$ins== inst,'notch.small.D2']#
      }#
#
    if(corr == 2){#
      offset.small.D1 <- 0#
      offset.small.D2 <- 0#
      notch.small.D1 <- beads.d1/beads.fsc#
      notch.small.D2 <- beads.d2/beads.fsc#
      }#
#
    if(corr == 3){#
        if(offset.small.D1 < 0 | offset.small.D2 < 0){#
                    offset.small.D1 <- 0#
                    offset.small.D2 <- 0#
                    notch.small.D1 <- beads.d1/beads.fsc#
                    notch.small.D2 <- beads.d2/beads.fsc}#
        }#
#
      opp <- subset(aligned, D1 <= fsc_small*notch.small.D1 + offset.small.D1 & D2 <= fsc_small*notch.small.D2 + offset.small.D2 |#
        D1  <= fsc_small*notch.large.D1 + offset.large.D1 & D2 <= fsc_small*notch.large.D2 + offset.large.D2)#
      if(nrow(opp) < 10) next#
#
      opp$pop <- 0#
      opp. <- subset(opp, fsc_small > 1)#
#
      print("Beads")#
        if(gate) {plot.cytogram(opp , "fsc_small", "pe")#
                        poly.beads <- getpoly(quiet=TRUE)#
                        write.csv(poly.beads,paste0(cruise,"data/", basename(file),"-polybeads.csv"),quote=F, row.names=F)#
                      }#
        poly.beads <-  read.csv(paste0(cruise,"data/", basename(file),"-polybeads.csv"))#
        b <- subset(opp,inout(opp[,c("fsc_small", "pe")],poly=poly.beads, bound=TRUE, quiet=TRUE))#
        opp[row.names(b),'pop'] <- "beads"#
#
      print("Syn")#
        if(gate) {poly.syn <- getpoly(quiet=TRUE)#
                        write.csv(poly.syn,paste0(cruise,"data/", basename(file),"-polysyn.csv"),quote=F, row.names=F)#
                      }#
        poly.syn <-  read.csv(paste0(cruise,"data/", basename(file),"-polysyn.csv"))#
        s <- subset(opp,inout(opp[,c("fsc_small", "pe")],poly=poly.syn, bound=TRUE, quiet=TRUE))#
        opp[row.names(s),'pop'] <- "synecho"#
#
      print("Pro")#
      x <- subset(opp, pop==0)#
        if(gate){plot.cytogram(opp , "fsc_small", "chl_small")#
                        poly.pro <- getpoly(quiet=TRUE)#
                        write.csv(poly.pro,paste0(cruise,"data/", basename(file),"-polypro.csv"),quote=F, row.names=F)#
                      }#
        poly.pro <-  read.csv(paste0(cruise,"data/", basename(file),"-polypro.csv"))#
        p <- subset(x,inout(x[,c("fsc_small", "chl_small")],poly=poly.pro, bound=TRUE, quiet=TRUE))#
        opp[row.names(p),'pop'] <- "prochloro"#
#
      print("Pico")#
      x <- subset(opp, pop==0)#
      if(gate) { poly.pico <- getpoly(quiet=TRUE)#
                      write.csv(poly.pico,paste0(cruise,"data/", basename(file),"-polypico.csv"),quote=F, row.names=F )#
                    }#
      poly.pico <-  read.csv(paste0(cruise,"data/", basename(file),"-polypico.csv"))#
      l <- subset(x,inout(x[,c("fsc_small", "chl_small")],poly=poly.pico, bound=TRUE, quiet=TRUE))#
      opp[row.names(l),'pop'] <- "pico"#
    if(corr == 0 | corr == 1 | corr == 2| corr == 3){#
          png(paste0(cruise,"data/", basename(file),"-offset",corr,".png"),width=9, height=12, unit='in', res=100)#
#
          if(nrow(opp)> 100000){opp. <- sample_n(opp, 100000)#
             } else opp. <- opp#
          par(mfrow=c(2,2))#
          plot.cytogram(aligned. ,  "fsc_small", "D1"); abline(b=notch.small.D1, a=offset.small.D1,col=2); abline(b=notch.large.D1, a=offset.large.D1,col=3); points(beads.fsc, beads.d1,pch=16, col=3)#
          plot.cytogram(aligned. , "fsc_small", "D2"); abline(b=notch.small.D2, a=offset.small.D2,col=2); abline(b=notch.large.D2, a=offset.large.D2,col=3); points(beads.fsc, beads.d2,pch=16, col=3)#
          plot.vct.cytogram(opp. , "fsc_small", "pe")#
          plot.vct.cytogram(opp. , "fsc_small", "chl_small")#
#
          dev.off()#
      }#
#
      n.opp <- nrow(opp)#
      n.opp. <- nrow(opp.)#
      n.evt <- nrow(evt)#
      n.evt. <- nrow(evt.)#
      beads <- nrow(b)#
      syn <- nrow(s)#
      pro <- nrow(p)#
      pico <- nrow(l)#
      filename <- basename(file)#
      if(cruise == 'MBARI1' | cruise == 'DeepDOM') filename <- paste(basename(dirname(file)),basename(file),sep="/")#
#
      all <- data.frame(cbind(file=filename, n.opp, n.opp., n.evt, n.evt., beads, pro, syn, pico, offset.small.D1, offset.large.D1,offset.small.D2, offset.large.D2, width, corr))#
#
      ALL <- rbind(ALL, all)#
#
    }#
  }#
#
write.csv(ALL, paste0(cruise,"data/seaflow-summary.csv"), quote=F, row.names=F)#
}
